# EventLoop相关

> ---
>
> JavaScript中分为**同步任务跟异步任务**。
>
> * 同步任务在**主线程**上运行，形成一个**执行栈**。
> * 而在主线程之外，还有**事件触发线程、定时器触发线程**，当某一个事件|定时器被触发时该线程会把对应的回调函数添加到**待处理队列**中，等待主线程处理。待处理队列有两个，分别是**宏任务队列跟微任务队列**。也就是说，当异步任务完成时，就会根据宏任务/微任务之分，将回调函数放到对应的任务队列中。
>
> ---

**事件循环**：

1、一旦执行栈为空，EventLoop就会**执行当前所有微任务**，清空微任务队列

2、微任务队列清空后，会在**宏任务队列中取下第一项宏任务**放入执行栈中执行，循环第一步



## 宏任务&微任务

JS中分为两种任务类型：**宏任务`macrotask`（task）**和**微任务 `microtask`（job）**

**macrotask：**可以理解是每次**执行栈执行的代码**就是一个宏任务（包括每次从**宏任务队列中获取一个回调并放到执行栈中执行**）

**microtask**：当前 **宏任务执行结束后立即执行的任务**（当前所有微任务都会执行）

- **macrotask**：**主代码块，setTimeout，setInterval等**
- **microtask：Promise，process.nextTick等**

```
task => process.nextTick => Promise => 渲染 => task  ……
```





# 浏览器的架构（进程、线程）

## 进程、线程

**进程**：是CPU分配资源的最小单位，是能**拥有资源（内存）和独立运行的最小单位**

**线程**：线程是**建立在进程的基础**上的一次程序运行单位，是**CPU调度**的最小单位。

* 线程**不能单独存在**，由进程来启动和管理

![image-20200721170928251](D:\Uttues\Basic-knowledge\浏览器\浏览器相关.assets\image-20200721170928251.png)

### 进程和线程之间的关系

1、进程中的**任意一线程执行出错**，都会导致整个进程的**崩溃**。

2、线程之间**共享进程中的数据**，可以对进程的**公共数据进行读写操作**

3、当一个**进程关闭**之后，操作系统会**回收进程所占用的内存**（即使有些线程使用不当，存在内存泄漏也都能回收）

4、**进程之间的内容相互隔离**，来保护操作系统中的进程互不干扰

---

> * IE 浏览器 - 多插件 - 容易内容泄露 - 内存占用越来越多 - 关闭则可回收
>
> * 进程只能访问自己的数据，必要时通过**进程间通信（IPC）**来进行数据通信
>
> * 一个进程的**崩溃 | 挂起** 不会影响到其他进程



## 过去的单进程浏览器

**单进程浏览器**：浏览器的所有功能模块都是运行在同一个进程里，包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。

![img](https://static001.geekbang.org/resource/image/6d/ca/6ddad2419b049b0eb2a8036f3dfff1ca.png)

---

**缺点**

* **不稳定**：**局部崩溃**会引起**整个浏览器的崩溃**（插件容易崩溃，渲染引擎模块执行Javascript时也容易崩溃）
* **不流畅**
  * **页面的渲染模块、JavaScript 执行环境以及插件** 运行在**同一个线程**中的。某一个任务执行时间过长会独占整个线程，页面没有机会占用线程执行任务，从而导致整个浏览器失去响应，变卡顿。
  * **页面的内存泄漏**也会使得单进程浏览器变得**越来越慢**，因为有时关闭页面可能出现内存无法回收的情况。

* **不安全**
  * **恶意插件**：用 C/C++ 等代码编写的**插件**可以获取操作系统的资源，存在安全隐患
  * **恶意脚本：** 恶意脚本可以利用**浏览器的漏洞**入侵到浏览器进程内部，甚至穿透浏览器攻击操作系统



## 目前的多进程浏览器

- **浏览器主进程**： 主要负责**界面显示、用户交互、子进程管理、文件储存**等功能
- **GPU进程**：网页、Chrome 的 UI 界面选择采用 **GPU 来绘制**，GPU成为普遍需求
- **网络进程**：面向渲染进程和浏览器进程等**提供网络下载功能**
- **渲染进程（浏览器内核）**：运行在**安全沙箱**中；负责把 HTML、JavaScript、CSS、图片等资源解析为可以显示、交互的页面
- **插件进程**：因为插件易崩溃，所以单独为插件进程来隔离，避免影响浏览器（**部分系统支持安全沙箱**）

![image-20200721193124028](D:\Uttues\Basic-knowledge\浏览器\浏览器相关.assets\image-20200721193124028.png)



### 渲染进程（浏览器内核）

浏览器中**默认每个Tab页面**都有一个**浏览器渲染进程（浏览器内核）**，用于**页面渲染，JS脚本执行，事件处理**等【多线程】

* **GUI渲染线程：**负责浏览器的渲染流程，解析 HTML、CSS，构建 DOM 树和 RenderObject 树，布局和绘制等
* **JS引擎线程（V8引擎|JS内核）**：处理Javascript脚本，等待任务队列中的任务到来**【单线程】**
* **事件触发线程**：控制**事件循环**，执行setTimeOut、鼠标点击时，**将对应事件添加到事件线程中**。当**事件被触发**时，将回调函数添加到 **宏任务|微任务队列**中
* **定时触发器线程**：负责setTimeout、setInterval**计时**（JS是单线程，阻塞会影响计时的准确），计时完成由事件触发线程添加回调到**宏任务队列**中
* **异步http请求线程**：负责异步HTTP请求，当检测到xhr状态变更时，产生对应的状态变更事件（事件触发线程处理回调）
* **（预解析线程）**：预加载HTML 文件中包含的 JavaScript、CSS 等相关文件



### 渲染进程如何与其他进程配合？

1. **在沙箱中运行的渲染进程无法发送网络请求的**，必须通过**进程间通信**，将请求传递给**浏览器主进程**，浏览器主进程交给**网络进程**来处理
2. **网络进程**获取网络资源后，**对响应内容进行解析**（检查字段判断是否跨域等等），检查无误则通过 IPC 将资源提交给**浏览器主进程**
3. **浏览器主进程 **通过 IPC 将资源传递给**渲染进程**
4. **渲染进程**会对资源进行解析、绘制等操作，最终渲染合成为一幅图片（并不负责将图片显示到界面上）
5. **渲染进程**将最终生成的图片提交给浏览器主进程，最终由**GPU进程**负责图片的显示

> （为什么渲染进程不请求网络资源？为什么渲染进程不显示图片？）



### 多进程浏览器如何改进单进程浏览器的缺陷

**不稳定** => **进程隔离**，单个页面、插件的崩溃不会导致整个浏览器崩溃

**不流畅** => 即使Javascript阻塞了某一个渲染进程，也**不会影响浏览器和其他页面**（依然流畅）

​             => 关闭页面，相当于关闭渲染进程，所占用的内存都会被系统回收（解决上述**页面内存泄漏问题**）

**不安全** => 可以将插件进程和渲染进程**运行在安全沙箱中**，即使是恶意程序也无法突破沙箱**直接攻击系统**（！！）



### 多进程浏览器的缺陷

* **更高的资源占用**：每个进程都会包含**公共基础结构的副本（如 JavaScript 运行环境）**，意味着多进程浏览器会消耗更多的内存资源
* **更复杂的体系架构**：浏览器各模块之间**耦合性高、扩展性差**等问题，会导致现在的架构已经很难适应新的需求了

> 目前还没有解决~ 漫长的迭代过程：面向服务架构（SOA）



### 其他进程模块

由于**渲染进程需要安全沙箱的保护**，因此需要把在渲染进程内部涉及到**和系统交互的功能**都转移到**其他进程模块**中去实现

**1、文件储存（浏览器主进程）**：管理Cookie 数据、缓存文件等的储存、文件读写

> 浏览器主进程会维护 Cookie 数据库，当渲染进程通过 JavaScript 来读取 Cookie 时，渲染进程会通过 IPC 将读取 Cookie 的信息发送给浏览器主进程，浏览器主进程读取 Cookie 之后再将内容返回给渲染进程。

**2、网络请求（网络进程）**

网络进程除了发出请求，接受响应之外，还接管了相关检查拦截功能

* 在处理 URL 请求之前，**会检查渲染进程是否有权限请求该 URL**，比如检查 XMLHttpRequest 或者 Fetch 是否是跨站点请求
* **检测 HTTPS 的站点中是否包含了 HTTP 的请求**

**3、用户交互**

渲染进程内部是**无法直接操作 窗口句柄 **的，这是为了**限制渲染进程监控到用户的输入事件**（恶意脚本读取用户输入密码）

> 其他操作系统应用程序可以在窗口句柄上进行绘制和接收键盘鼠标消息。

所以有以下两点改变：

* 渲染进程需要**渲染出位图**，交给**浏览器主进程**显示到屏幕上（GPU进程）
* 操作系统**将用户的输入事件传递给浏览器主进程**，浏览器主进程再根据当前浏览器界面的状态来判断如何调度这些事件：
  * 如果当前焦点位于**浏览器地址栏**中，则输入事件会在浏览器主进程内部处理
  * 如果当前焦点在**页面的区域**内，则浏览器主进程会将输入事件转发给渲染进程

---

目的：限制渲染进程有监控到用户输入事件的能力，所以所有的键盘鼠标事件都是由浏览器主进程来接收的，然后浏览器主进程再通过 IPC 将这些事件发送给渲染进程。



## 浏览器架构如何影响操作系统安全

#### 单进程浏览器 & 浏览器漏洞

**浏览器本身的漏洞**是**单进程浏览器**的主要安全问题，其中最常见的攻击方式是利用**缓冲区溢出**

* 因为**黑客注入的恶意脚本**跟浏览器内核**运行在同一个进程中**，可以**利用漏洞对浏览器、OS实施攻击**
  * **入侵到浏览器进程内部**，读取和修改浏览器进程内部的任意内容
  * **穿透浏览器**，对用户的**操作系统**执行恶意操作（安装恶意软件、监听用户键盘输入信息、读取硬盘文件内容等）
* **单进程浏览器**需要频繁访问或者修改操作系统的数据，**无法用安全沙箱**来保护

---

> **通过浏览器漏洞进行的攻击**不同于XSS攻击：XSS **无法对操作系统进行攻击**，只是将恶意脚本注入到页面中，窃取数据



#### 多进程浏览器 & 安全沙箱

**思想：**

* 在**安全沙箱**里运行渲染进程，从而**隔离渲染进程与操作系统**，渲染进程**无法访问|修改操作系统中的数据**（恶意脚本也不能）
* 在**浏览器内核**中实现**与操作系统交互**的功能。通过**进程间通信（IPC）**实现浏览器内核与渲染进程的交互，从而**满足渲染进程访问系统资源的需求**

---

> ##### 问1：为什么要在安全沙箱里运行渲染进程？
>
> * 因为渲染进程中运行着**网络获取的资源**（不安全，不可信），如果渲染进程中存在**系统级别的漏洞**，那么以上操作就有可能让恶意的站点获取到渲染进程的控制权限，进而又获取操作系统的控制权限，这对于用户来说是非常危险的
> * 下载不运行就无害，所以网络进程、浏览器主进程无需安全沙箱
>
> ##### 问2：什么是安全沙箱？
>
> * 浏览器中的安全沙箱是利用**操作系统提供的安全技术**，其**最小保护单位是进程**
> * 因为**单进程浏览器**需要**频繁访问或者修改操作系统的数据**，所以无法运行在安全沙箱中

---



## Chrome的站点隔离

**过去（标签级的渲染进程）：**一个标签页为一个渲染进程

**问题：**一个标签页中可能包含了多个不同站点的 iframe => **不同站点的iframe运行在同一个渲染进程中**（恶意iframe利用系统漏洞实施攻击）

**现在（iframe级的渲染进程）：严格按照同一站点的策略来分配渲染进程。** **将同一站点（包含了相同根域名、协议的地址）中相互关联的页面放到同一个渲染进程中执行**，从而**将恶意的 iframe 隔离在恶意进程内部**，使得它**无法继续访问其他 iframe 进程的内容**

* 通常情况下两个页面会有两个渲染进程，如果页面里有iframe的话，iframe也会运行在单独的进程中
* 如果两个页面属于同一站点的话，并且从a页面中打开的b页面，那么他们会公用一个渲染进程



## JavaScript为什么是单线程的

作为浏览器脚本语言，JavaScript本质上也是一种GUI变成，主要用途是**与用户互动，处理各种事件以及操作DOM，这决定了它只能是单线程**，否则会带来很复杂的**同步问题**。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，浏览器可能不知道要以哪个线程为准



## Web Worker（HTML5）

为了利用**多核CPU**的计算能力，**HTML5**提出Web Worker标准，**允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM**。

所以，这个新标准**并没有改变JavaScript单线程的本质**。



# 从输入 URL 到页面展示

![img](https://static001.geekbang.org/resource/image/1f/e0/1f4f8c194b02975f6d2848b7b73175e0.png)

![img](https://static001.geekbang.org/resource/image/92/5d/92d73c75308e50d5c06ad44612bcb45d.png)

1、**用户输入**：在浏览器地址栏输入 URL

2、**处理输入信息：**浏览器主进程会解析输入的字符串，判断是**URL**还是**搜索关键字**

- 如果用户输入的是**搜索关键字**则结合**默认搜索引擎**合成新的URL
- 如果用户输入的是**URL**则**检查URL格式**，在URL前**组装协议**（默认http），构成**完整的URL** https://www.baidu.com

> 用户输入完内容回车：（当前页面即将要被替换成新的页面）
>
> * **当前页面**触发 **beforeunload 事件**：数据清理，询问是否离开等**（可以取消导航！）**
> * **浏览器导航栏显示loading状态**，但页面还是**前一个页面**，需要等待**提交文档**阶段，页面内容才会被替换

3、**浏览器主进程**通过**进程间通信（IPC）**将URL请求发送给网络进程处理 ↓↓

---

---

4、网络进程先**检查本地是否缓存了该请求资源**：如果**有且可用**，则直接返回资源给浏览器主进程（200），

5、如果没有，**网络进程开启网络请求流程**，流程如下：

- **域名映射**，获取域名对应的**IP地址和端口号**：静态映射**（DNS缓存）**、动态映射**（递归DNS查询）**
  - 如果没有端口号，HTTP默认80，HTTPS默认443
  - 如果是HTTPS请求，还需要建立TLS连接
- **利用 IP地址 和服务器建立TCP连接**：6个TCP连接，有可能排队/直接建立连接
- 浏览器**构建请求行、请求头**等信息，携带该域名下的Cookie并发送网络请求，服务器处理请求并**返回响应**
  - 扩展：数据包在五层网络模型中的传递

- **网络进程**接收服务端响应，并**解析响应内容**
  - **解析响应头，检查状态码**
    - 300 301重定向：网络进程从响应头的 Location 字段中读取重定向地址，重新发起网络请求
    - 200 继续处理请求
  - **200 检查响应数据类型 Content-Type**
    - 如果是**字节流**类型 application/octet-stream，则将响应提交给**下载管理器**，**导航流程**结束
    - 如果是**文档**类型 text/html，则**通知浏览器主进程**！
  - **根据Connection字段来判断是否断开TCP连接**，Connection: Keep-Alive表示**持久连接**，否则断开TCP连接

---

---

6、**浏览器主进程获取网络进程的通知**，选择 **复用渲染进程 | 创建一个新的渲染进程**

* 默认情况下，每打开一个新页面就会配套**创建一个新的渲染进程**
* 如果页面A中打开页面B，并且而页面A和页面B属于**同一站点**，那么新页面会**复用父页面的渲染进程**

7、【提交文档】浏览器主进程**向渲染进程发出 “提交文档” 的消息**；

8、渲染进程收到消息后，**和网络进程建立**传输的**“数据管道”**来进行文档数据的传输；

9、【确认提交】文档数据传输完成后，**渲染进程返回“确认提交”的消息给浏览器主进程**，表示渲染进程要开始进行页面渲染**（结束导航流程 => 进入渲染阶段）**

---

---

10、**浏览器主进程接收到 “确认提交”** 的消息后，会更新浏览器的当前页面状态（包括安全状态、地址栏的 URL、前进后退的历史状态），更新当前页面，此时的Web页面是空白页（还没渲染完）

---

---

11、渲染进程负责**浏览器的页面渲染**（具体包括文件的**解析**以及**渲染**）

- 构建DOM树 => 样式计算 => 构建布局树 => 布局计算 => 分层 => 生成绘制列表 => 分块 => 光栅化 => 合成与显示

12、一旦页面生成完成，渲染进程会**发送一个消息给浏览器进程**，浏览器接收到消息后，**会停止标签图标上的加载动画。**

---

> 同一站点：根域名和协议相同
>
> **导航过程**：用户发出 URL 请求到**页面开始解析（渲染进程获取文档数据）**的过程
>
> **提交文档：** **浏览器进程**将网络进程接收到的 HTML 数据提交给渲染进程





## 解析IP地址查找顺序

- 查找的是**浏览器的DNS缓存**
- 查询**系统缓存**：首先检查域名是否在本地 hosts 文件 里,再查系统本地缓存的其他DNS 记录
  - hosts是一个没有扩展名的**系统文件**，作用是将常用的**网址域名**与对应的 **IP 地址**建立一个**关联“数据库 ”**。
- 查找**路由器缓存**
- 查找 **ISP DNS缓存**（ISP 互联网服务提供商，也就是电信网、移动网、联通网）
- **递归 DNS查询**
  - DNS是由**分层的DNS服务器**实现的分布式数据库（也表示一个**允许主机查询分布式数据库**的**应用层协议**）
  - 在专门的DNS服务器上配置**主机到IP地址的映射**，需要时就发送**域名解析请求**。





# 浏览器渲染相关

## 浏览器渲染过程（渲染流水线）

#### （一）构建DOM树  ——  HTML文件（字节数据）=>字符串=>Token=>Node=>DOM

* **HTML文件**中存储的是HTML的**原始字节数据**，根据的指定文件**编码**（例如 UTF-8）将字节数据转换成**HTML字符串**
* **词法分析（标记化）**：根据**HTML规范**，采用**分词器**来将字符串**转换成各种Token标**签，后续会转化为**Node节点**
* **语法分析**（**建树**）：用Node结点构建一个**多叉树的对象模型**，也就是DOM树

---

> **HTML 解析器（HTMLParser）**：将 HTML 字节流转换为 DOM 结构
>
> * HTML 解析器并不是等整个文档加载完成后再解析的，而是**一边从网络进程处获取数据，一边解析数据**
> * 内部维护了一个 **Token 栈结构**，该 Token 栈主要用来**计算节点之间的父子关系**
>   * 开始Token入栈，创建Node节点添加到树中，**Node节点中定义属性和规则**
>   * 文本Token不入栈，创建文本节点添加到树中
>   * 结束Token会使得对应的栈顶开始Token出栈，不创建节点
>
> **HTML规范**中规定了**HTML文件的解析算法**，具体包括**词法分析（标记化）**和**语法分析（建树）**两个阶段
>
> **HTML规范**中的**容错机制**：使用</ br>而不是< br>、表格离散、表单元素嵌套时会忽略内部的form

---



#### （二）样式计算  ——  建树、标准化、计算， 最终得到每个 DOM 节点的样式

1、**构建CSSOM树**：字节数据 => 字符串 => Token => Node =>  CSSOM 【document.**styleSheets**查看】

2、**标准化样式属性值**，转化为**可计算值**：em -> px、red -> #ff0000、bold -> 700

3、**计算出 DOM 树中节点的具体样式**：**继承、层叠**，从最通用的规则开始，**递归遍历CSSOM树**最终确定

* **继承**：默认继承**父节点**的样式属性，父无则用浏览器的默认样式 **UserAgent样式**
* **层叠**：如何合并来自多个源的属性值，得到最终的节点样式

> **这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 window.getComputedStyle 内**



#### （三）创建布局树  ——  布局树只会包含需要显示的节点及其样式信息

* 将 **DOM 树和 CSSOM 树组合为布局树**，有**遍历**并且过滤掉不可见的节点（display: none | head 结点）

![image-20200722150755586](D:\Uttues\Basic-knowledge\浏览器\浏览器相关.assets\image-20200722150755586.png)



#### （四）布局 ——  计算布局树中可见节点在页面中的确切位置和大小（记录在布局树中）



#### （五）分层 ——  对布局树进行分层，并生成图层树 LayerTree【合成层，GPU】

* **渲染引擎会为特定的节点生成专用的图层**，并生成一棵对应的**图层树**
* 因为页面中有很多**复杂的效果**，包括：如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，构建图层树可以更加方便地实现这些效果

> 如果一个节点没有对应的层，那么这个节点就从属于父节点的图层

![image-20200722153932403](D:\Uttues\Basic-knowledge\浏览器\浏览器相关.assets\image-20200722153932403.png)



#### （六）生成绘制列表 —— 将一个图层的绘制拆分成多个小的绘制指令（还没有真的绘制）

* 当图层的**绘制列表准备好之后**，**主线程**会把该**绘制列表提交（commit）给合成线程**来执行绘制操作



#### （七）分块 —— 合成线程会将图层划分为图块（通常是 256x256 或者 512x512）

- **原因**：视口有限，如果一口气绘制出来十分浪费性能，并且不一定会立马被看到

  ![image-20200722155504030](D:\Uttues\Basic-knowledge\浏览器\浏览器相关.assets\image-20200722155504030.png)



#### （八）光栅化 —— 将图块栅格化，转化为位图

**合成线程**会**优先**将**视口附近**的图块经过**栅格化操作**来**转化为位图** 【栅格化：图块 => 位图】

* 渲染进程维护了一个栅格化的**线程池**，所有的图块栅格化都是在**线程池**内执行的

* **GPU**：通常，栅格化过程都会**使用 GPU 来加速生成**，使用 GPU 生成位图的过程叫 **快速栅格化 | GPU 栅格化**
  * 渲染进程把**绘制图块的指令**发送给 GPU进程，由 **GPU 合成**对应的位图，并保存在 **GPU 的内存中**



#### （九）合成和显示  ——  将位图转换成屏幕上的像素

- 一旦所有图块都被光栅化，**合成线程发送绘制图块命令 DrawQuad 给浏览器进程**
- 浏览器进程根据DrawQuad消息**生成页面**，**把页面内容保存到内存中**，并**把这部分内存发送给显卡**
- 显卡就会将页面**合成相应的图像**，保存到**后缓冲区**中【双缓冲】

---

> 为什么发送给显卡？
>
> * 无论是 PC 显示器还是手机屏幕，都有一个固定的**刷新频率**，一般是 60 HZ，即 60 帧，也就是一秒更新 60 张图片，一张图片停留的时间约为 16.7 ms。而每次可见的图片都来自显卡的**前缓冲区**。
>
> * 显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到**后缓冲区**，然后系**统自动将前缓冲区和后缓冲区对换位置，如此循环更新**。
>
> 动画卡顿为什么会出现？
>
> * 当某个动画大量**占用内存**的时候，浏览器**生成图像**的时候会**变慢**，**图像传送给显卡就会不及时**，而显示器还是以**不变的频率刷新**，因此会出现**卡顿**，也就是明显的**掉帧**现象。

![image-20200722161913708](D:\Uttues\Basic-knowledge\浏览器\浏览器相关.assets\image-20200722161913708.png)



## 渲染流水线为什么需要 CSSOM

1. 提供给 JavaScript 操作样式表的能力
2. 为布局树的合成提供基础的样式信息



## 什么情况下渲染引擎会为节点创建新的图层

> 什么情况下结点会被提升为一个单独的合成层？【占用内存】

**显式提升**

* 拥有**层叠上下文**属性的元素会被提升为单独的一层
  * HTML根元素< html>
  * **position为 absolute|relative **并且**设置了z-index属性（不为auto）**
  * **position为 fixed|sticky **
  * flex容器、grid容器的子元素，且 z-index 值不为 auto
  * 元素的 **opacity 值 < 1**
  * 元素的 transform|filter 值不为 none
  * **will-change 值**设定为**任一属性并且该属性为非初始值**（opacity、transform、top、left、bottom、right）

* **需要剪裁的地方**，渲染引擎会为**文字部分**单独创建一个层，如果出现**滚动条**，滚动条也会被提升为单独的层

---

**隐式合成**：**z- index较低** 的节点被提升为**单独的图层**后，所有**层叠等级比它高的节点都会**成为一个单独的图层

* **隐式合成隐藏着巨大的风险**，**层爆炸**：可能会增加上千个不必要的图层，**增加内存压力**，甚至导致**页面崩溃**
* **解决方案**：打破 overlap 的条件，让**其他元素不要和合成层元素重叠**。也就是当我们**使用3D硬件加速提升动画性能**时，最好**给元素增加一个z-index属性**，**人为干扰合成的排序**，可以有效减少chrome创建不必要的合成层，**提升渲染性能**

---

> [层叠上下文 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context)
>
> 页面是个二维平面，但是**层叠上下文**能够让 HTML 元素具有**三维概念**
>
> 拥有层叠上下文的元素**按照自身属性的优先级**分布在垂直于这个二维平面的 z 轴上
>
> ![image-20200722154716125](D:\Uttues\Basic-knowledge\浏览器\浏览器相关.assets\image-20200722154716125.png)





## 回流、重绘、直接合成相关

### 回流、重绘 | 直接合成（GPU加速）

**浏览器渲染过程：**

构建DOM树 => 样式计算 => (构建布局树 => 布局计算) =>  分层  => 生成绘制列表 => 分块 => 光栅化 => 合成与显示

![image-20200722170234462](D:\Uttues\Basic-knowledge\浏览器\浏览器相关.assets\image-20200722170234462.png)

---

#### 回流

* **布局树** 因为**元素的几何属性、布局、隐藏**等改变而需要**重新构建**【触发**重新布局**，重新计算节点位置和大小】

![image-20200722171059363](D:\Uttues\Basic-knowledge\浏览器\浏览器相关.assets\image-20200722171059363.png)



#### 重绘

- **更新元素的绘制属性**，只影响元素的**外观、风格，不会影响布局**【可以**直接跳过 布局、分层 阶段**】

![image-20200722171115749](D:\Uttues\Basic-knowledge\浏览器\浏览器相关.assets\image-20200722171115749.png)



#### 直接合成【GPU加速】

https://juejin.im/post/5da52531518825094e373372

* **直接合成**：更改一个**不需要布局、绘制**的属性，则**会直接执行非主线程上的合成操作**，这个过程叫做**直接合成**
  * 在**合成**时，会**跳过布局、绘制**，直接进入**非主线程处理**的部分，即**直接交给合成线程处理**【GPU线程池，**GPU加速**】
* **应用**：使用**CSS 的 transform** 实现动画效果，用 CSS3 的**will-change**: **transform** 触发合成GPU加速等

![image-20200722171738726](D:\Uttues\Basic-knowledge\浏览器\浏览器相关.assets\image-20200722171738726.png)



---

##### GPU硬件加速|合成层的优点

- **充分发挥GPU擅长处理位图数据的优势**： **合成线程**生成位图时**调用线程池**，**使用GPU进行加速生成**【比CPU处理快，虽然好像其他的也是GPU】
- 合成线程**没有占用主线程的资源**，即使主线程卡住了，效果依然能够流畅地展示
- **发生改动时**可以直接跳过布局、绘制等流程，**避免引起回流重绘**
- 层独立，避免自己的改动影响到其它图层

##### GPU硬件加速|合成层的缺点

1. 合成层占用会内存
2. 处理不当可能引起层爆炸（处理不当：隐式合成）



### 常见引起回流的属性和方法

> 特点：会改变元素几何信息：**位置/尺寸大小**

1. 添加或者删除可见的DOM元素
2. 元素尺寸改变——边距、填充、边框、宽度和高度
3. 内容变化，比如用户在input框中输入文字
4. 浏览器窗口尺寸改变——resize事件发生时
5. **获取 offsetWidth、scrollTop、clientTop等属性**，会重新进行**样式计算和布局**【布局抖动预警】
6. **设置 style 属性的值 /** 调用了 **getComputedStyle** 方法（**每个都会造成回流**）



### 常见引起重绘的属性和方法

![img](https://image.fundebug.com/2019-01-03-9.png)



### 如何减少回流、重绘

- **将频繁重绘或者回流的节点提升为合成图层**：不占主线程资源，不回流重绘【**transform 替代 top 等属性**】
- **使用 visibility 替换 display: none** （前者只会引起重绘，后者会引发回流、重绘）
- 对于 **resize、scroll** 等采用**防抖/节流**处理

- **不要使用 table 布局**，可能很小的一个小改动会造成整个 table 的重新布局

- 动画实现的速度的选择，**动画速度越快，回流次数越多**；可以选择使用 requestAnimationFrame / 合成动画

---

- 批量DOM操作：使用**DocumentFragment** 来合并多次DOM节点的增删操作
- 批量内联样式操作：使用**类名class来合并样式**，避免逐项直接设置style
- 避免在**for循环**里 **读取节点属性offsetWidth|反复调用getComputedStyle()**，会引起**布局抖动**（多次**强制同步布局**）





## 渲染页面时有哪些常见不良现象

* **无样式内容闪烁**：在CSS加载之前，先呈现了HTML【不同浏览器渲染机制相关】

* **白屏**：对于 **DOM+CSSOM => 布局树** 的浏览器渲染机制
  * 将**CSS部分放在HTML尾部**，加载慢
  * 把**js文件放在头部**阻塞其后组件的下载，出现白屏问题





## Javascript脚本相关

### script标签中async和defer的区别

* **无defer、async**：**立即加载并执行**指定的脚本，**加载和执行**都阻塞当前DOM加载
* **defer**：**异步加载，延时执行**【有顺序】
  * 异步加载不阻塞DOM树，**DOM解析完|DOMContentLoaded事件触发前**执行 defer-script脚本
* **async**：**异步加载，加载好立即执行**【无顺序】



### 为什么Javascript操作DOM很慢？

**DOM操作** 是属于**GUI渲染线程**所控制的，而 **执行JS** 又是 **JS 引擎线程**中的东西（线程互斥）

*  **JS 操作 DOM** **涉及到了两个线程之间的通信**，存在**性能上的损耗**，线程上下文切换也有代价
* 操作 DOM 可能还会带来**重绘回流**的情况，所以也就导致了性能上的问题。



### JavaScript 如何阻塞 DOM 树渲染

#### 1、下载 JavaScript 脚本会阻塞 DOM 树

**存在问题**：下载耗时，受到网络环境、JavaScript 文件大小等因素的影响。

**Chrome 浏览器的优化 —— 预解析**：当**渲染引擎**收到**HTML字节流**之后，会开启一个**预解析线程**，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，一旦发现相关文件，**预解析线程会提前下载这些文件**。

**性能优化策略：**

* 提高加载速度：使用 CDN 来加速 JavaScript 文件的加载（网络），压缩 JavaScript 文件的体积（文件大小）
* **异步加载脚本**：如果 JavaScript 文件中**没有操作 DOM 相关代码**，可以设置为**异步加载**（async 或 defer）

#### 2、执行 JavaScript 脚本会阻塞 DOM 树（线程互斥）

**原因：**由于JavaScript是可操纵DOM的，如果在修改元素属性的同时渲染界面（线程同时运行），**就可能无法预料渲染线程输出的效果**

* 先JS：为了**防止js操作了dom**等

**表现**：为了防止**渲染出现不可预期**的结果，浏览器设置**GUI渲染线程与JS引擎为互斥**的关系，**当解析到script标签时，执行内嵌的Javascript代码，GUI渲染线程会被挂起**（HTML 解析器暂停工作），**GUI更新操作**则会被保存在一个队列中等**到JS引擎线程空闲**时立即才被执行。

**性能优化策略：**

* 将 script 标签**放在 body 标签底部**
* 为script标签指定 **async 或 defer**来延迟脚本
  * **async**表示js加载时不会阻塞DOM解析，但会在下载完成后立刻执行（阻塞）
  * **defer**则会在下载完成并且整个文档解析完成、DOMContentLoaded事件被触发前开始执行

#### 3、执行 JavaScript 会导致 CSSOM 的构建阻塞 DOM 树

执行Javascript脚本时，会被 **在Script标签前面引入的CSS** 阻塞，只有CSSOM构建完毕后，执行JavaScript【间接阻塞了DOM树的构建】

**原因**：Javascript可以**修改样式**，而**不完整的CSSOM是无法使用的**。所以浏览器会保证在JavaScript文件执行之前，加载完并完成CSSOM的构建

* 浏览器通常会认为**该脚本依赖于脚本前引入的样式的渲染结果**， 也就更倾向于延迟脚本的执行（直到样式渲染结束）

* **原本DOM和CSSOM的构建是互不影响**，**并行构建**

![image-20200723122127906](D:\Uttues\Basic-knowledge\浏览器\浏览器相关.assets\image-20200723122127906.png)

---

> 因此要尽量**避免JS进行巨大计算，导致执行时间过长**，会造成**页面的渲染不连贯**，或产生卡顿的感觉。
>
> 提高**首屏渲染速度**：
>
> * 尽量不在首屏加载JavaScript文件，将 script 标签**放在 body 标签底部**
> * 或者是为script标签指定 **async 或 defer**来延迟脚本





### JavaScript 如何延迟 DOMContentLoaded 触发

1、JavaScript 如何阻塞 DOM 树渲染

2、脚本可能修改 DOM，甚至执行 `document.write` 操作



## CSS加载是否会阻塞dom树渲染

- **CSS加载**不会阻塞DOM树解析（CSS是由**单独的下载线程异步下载**的）
- JavaScript 脚本依赖其前面引入的样式表，所以**执行 JavaScript** 会导致 CSSOM 的构建阻塞 DOM 树
- CSS**加载**和CSS规则树的**构建**会**阻塞布局树的构建**（因为**render树需要CSS信息**）



## 页面生命周期

**DOMContentLoaded**：**DOM树，也就是页面元素加载完毕**，此时可以正常**交互**，比如滚动，输入字符等；**无需等待样式表等**的完成加载

* jQuery 中： **`$(document).ready()`** 监听的就是 DOMContentLoaded 事件

**load** ：页面上**所有的资源（图片，音频，视频等）加载完成**，可以获取图像大小。

* jQuery 中：**`$(document).load() / window.onload()`** 监听的是 load 事件。

**beforeunload**：用户**即将离开**（开启新的导航流程/关闭页面）

**unload**：用户几乎已经离开了，但是仍然可以启动一些操作，比如发送统计数据。













# 性能优化相关

## Chrome开发者工具

- 与**调试页面相关**的有 Elements 面板、Sources 面板、Console 面板等。
- 与**性能相关**的有网络面板、Performance 面板、内存面板等；

![img](https://static001.geekbang.org/resource/image/c5/82/c5eb9603e79547ae3d815254e24d4782.png)



## 网络阶段

- **请求排队**：请求不能立即执行
- **代理协商**：**代理服务器**连接协商所用的时间，如果用了代理服务器才有
- **建立连接**：和服务器建立连接（TCP+SSL握手）
- **发送请求**：网络进程将请求数据发送给网络（请求数据放在浏览器缓冲区中）
- **第一字节时间 TTFB**：**网络请求被发起**到从服务器**接收到第一个字节**的时间，反映服务端响应速度的重要指标
- **资源加载时间**：从第一字节时间到接收到全部响应数据所用的时间

### 导致网络请求处于排队状态的原因

1. 页面中的**资源是有优先级的**，通常非核心资源遇到核心资源（JS、HTML、CSS）时，需要“让路”
2. **队头阻塞（长链接）**：并发连接不够用
3. **网络进程在为数据分配磁盘空间**时，新的 HTTP 请求也需要短暂地**等待磁盘分配结束**。

### 导致第一字节时间过久的原因

1. **服务器生成页面数据的时间过久**
2. **网络原因**：低带宽服务器；联调用户访问电信服务器
3. 发送请求头时带上了**多余的Cookie信息**：服务器接收到这些 Cookie 信息之后可能需要对每一项都做处理



### 网络阶段的性能优化

1. **减少请求排队时间**：域名分片（过时了）；**把站点升级到 HTTP2**
   - 域名分片：把1 个站点下面的资源放在多个域名下（6*n个连接）
   - HTTP2 采用多路复用来消除HTTP/1.1中队头阻塞的问题
2. **减少第一字节时间**
   - 提高服务器的处理速度
   - CDN缓存静态文件 + 利用浏览器缓存技术（解决网络问题）
   - 发送请求时就去尽可能地减少一些不必要的 Cookie 数据信息



## 首屏、白屏时间 及其计算方法

**白屏时间** =  浏览器**出现第一个元素** - 地址栏输入网址后回车【提交文档+**解析白屏（真的白屏）**】

* 解析白屏时间过久，就会影响到用户体验

**首屏时间** =  浏览器**首屏内容渲染完成** - 地址栏输入网址后回车

---

**白屏时间计算方法：** 

* 在head标签**头尾插入两个script计算**时间差
  * 通常认为浏览器**开始渲染 `<body>` 或者解析完 `<head>`** 的时间是白屏结束的时间点
* performance api

**首屏时间计算方法：** 

* **首屏模块标签标记法**：在此元素后面加入 `script` 计算时间（假定当解析到某个元素时相当于首屏完成）
* **统计首屏内加载最慢的图片/iframe**
  * 通常首屏中**加载最慢**的就是图片或者 iframe 资源，因此可以理解为当图片或者 iframe 都加载出来了，首屏肯定已经完成了。
  * 浏览器对每个页面的 **TCP 连接数**有限制，使得并不是所有图片都能立刻开始下载和显示。
  * 方法：监听首屏内**所有图片的 onload 事件**，获取 **onload 最大值**，并用这个值减去 navigationStart 即可获得近似的首屏时间



## 用户可交互时间

**用户可交互时间：** = domContentLoadedEventEnd - navigationStart

* 当domContentLoaded事件触发时，意味着**页面元素加载完毕**，可以正常**交互**





## 影响页面展示的因素以及优化策略 / 首屏、白屏优化

### 阶段一：主进程接收到渲染进程“确认提交”的消息前【展示前一个页面】

#### 浏览器对URL进行DNS解析

**【DNS Prefetch / DNS预解析】**：**提前解析之后可能会用到的域名**并缓存结果 | 缓存**访问过的**页面域名

- **自动解析：**遇到`a`标签，**浏览器会自动将`href`中的域名解析为IP地址**，解析过程与用户浏览网页**并行处理**的。
  - 为了确保安全性，在`HTTPS`页面中不会自动解析

* **手动解析**：可以在在**包含有url的标签**上添加**rel="dns-prefetch"来触发浏览器的dns预解析**（img）

#### 浏览器与服务器进行TCP连接

#### 客户端请求、服务端响应

* **减少请求排队时间**：域名分片（过时了）；**把站点升级到 HTTP2**（采用多路复用来消除HTTP/1.1中队头阻塞的问题）
* **减少请求次数**
  * **资源合并**：用**webpack**来对**静态资源**进行打包；用**雪碧图**来合并多个小图（background-position定位）
  * **前端缓存**：Service Worker Cache、内存缓存、磁盘缓存（HTTP Cache  -  强缓存）
  * **本地存储**：cookie、localStorage、sessionStorage

* **减少第一字节时间**
* **缩小响应体积 | 减少资源加载时间**
  * **资源合并**：**Gzip**、**代码**丑化压缩、**图片**压缩、CSS的Tree shaking去除冗余代码
  * **在不同分辨率下保存多个版本的光栅图像**，能用小的就不用大的图
  * 选用正确格式的图片
    * PNG：无损格式，压缩率一般，支持透明背景，常用于透明图片或者Icon等。
    * **JPG**：有损格式，压缩率较好，常用于复杂的大图，不支持透明背景。
    * SVG：矢量图形，可编程。在各分辨率下不失真，但是渲染复杂图形较消耗性能。常用于简单图形。
  * WEBP：无损格式，相较于PNG和JPG来说，压缩率更好，同时支持透明背景，但兼容性差
  
* **CDN加速：**CDN是依靠部署在各地区的边缘服务器，主要的关键技术是**内容存储和分发技术**，**达到用户就近获取内容，降低网络拥塞，提高用户访问速度和命中率的目的**
* **减少请求中多余的Cookie信息**：1. 降低请求体积、2. 减少服务端处理请求的时间

### 阶段二：渲染进程创建空白页面【解析白屏】

> **白屏阶段**：解析 HTML、下载 CSS、下载 JavaScript、生成 CSSOM、执行 JavaScript、生成布局树、绘制页面
>
> **影响白屏时间的因素**：服务端性能、网络、前端页面结构设计

#### 页面渲染

- **服务端渲染**：能够有效加快首屏渲染速度（SEO优化；对服务器有压力）


* **客户端请求、服务端响应**：减少请求次数、减小响应体积、CDN加速 ……
* 前端页面结构设计，**避免 JS | CSS 阻塞DOM树**

- **避免回流与重绘**：合成层、合成动画、独立图层抽取（避免绘制不需要重新绘制）
- **懒加载**：用到时再加载

### 阶段三：从首次渲染到完整页面的绘制阶段【白屏-首屏】

> **影响首屏时间的因素**：白屏时间、资源下载速度（跟白屏差不多？懒加载）

