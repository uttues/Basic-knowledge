# EventLoop相关

> ---
>
> JavaScript中分为**同步任务跟异步任务**。
>
> * 同步任务在**主线程**上运行，形成一个**执行栈**。
> * 而在主线程之外，还有**事件触发线程、定时器触发线程**，当某一个事件|定时器被触发时该线程会把对应的回调函数添加到**待处理队列**中，等待主线程处理。待处理队列有两个，分别是**宏任务队列跟微任务队列**。也就是说，当异步任务完成时，就会根据宏任务/微任务之分，将回调函数放到对应的任务队列中。
>
> ---

**事件循环**：

1、一旦执行栈为空，EventLoop就会**执行当前所有微任务**，清空微任务队列

2、微任务队列清空后，会在**宏任务队列中取下第一项宏任务**放入执行栈中执行，循环第一步



## 宏任务&微任务

JS中分为两种任务类型：**宏任务`macrotask`（task）**和**微任务 `microtask`（job）**

**macrotask：**可以理解是每次**执行栈执行的代码**就是一个宏任务（包括每次从**宏任务队列中获取一个回调并放到执行栈中执行**）

**microtask**：当前 **宏任务执行结束后立即执行的任务**（当前所有微任务都会执行）

- **macrotask**：**主代码块，setTimeout，setInterval等**
- **microtask：Promise，process.nextTick等**

```
task => process.nextTick => Promise => 渲染 => task  ……
```





# 浏览器的架构（进程、线程）

## 进程、线程

**进程**：是CPU分配资源的最小单位，是能**拥有资源（内存）和独立运行的最小单位**

**线程**：线程是**建立在进程的基础**上的一次程序运行单位，是**CPU调度**的最小单位。

* 线程**不能单独存在**，由进程来启动和管理

![image-20200721170928251](D:\Uttues\Basic-knowledge\浏览器\浏览器相关.assets\image-20200721170928251.png)

### 进程和线程之间的关系

1、进程中的**任意一线程执行出错**，都会导致整个进程的**崩溃**。

2、线程之间**共享进程中的数据**，可以对进程的**公共数据进行读写操作**

3、当一个**进程关闭**之后，操作系统会**回收进程所占用的内存**（即使有些线程使用不当，存在内存泄漏也都能回收）

4、**进程之间的内容相互隔离**，来保护操作系统中的进程互不干扰

---

> * IE 浏览器 - 多插件 - 容易内容泄露 - 内存占用越来越多 - 关闭则可回收
>
> * 进程只能访问自己的数据，必要时通过**进程间通信（IPC）**来进行数据通信
>
> * 一个进程的**崩溃 | 挂起** 不会影响到其他进程



## 过去的单进程浏览器

**单进程浏览器**：浏览器的所有功能模块都是运行在同一个进程里，包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。

![img](https://static001.geekbang.org/resource/image/6d/ca/6ddad2419b049b0eb2a8036f3dfff1ca.png)

---

**缺点**

* **不稳定**：**局部崩溃**会引起**整个浏览器的崩溃**（插件容易崩溃，渲染引擎模块执行Javascript时也容易崩溃）
* **不流畅**
  * **页面的渲染模块、JavaScript 执行环境以及插件** 运行在**同一个线程**中的。某一个任务执行时间过长会独占整个线程，页面没有机会占用线程执行任务，从而导致整个浏览器失去响应，变卡顿。
  * **页面的内存泄漏**也会使得单进程浏览器变得**越来越慢**，因为有时关闭页面可能出现内存无法回收的情况。

* **不安全**
  * **恶意插件**：用 C/C++ 等代码编写的**插件**可以获取操作系统的资源，存在安全隐患
  * **恶意脚本：** 恶意脚本可以利用**浏览器的漏洞**入侵到浏览器进程内部，甚至穿透浏览器攻击操作系统



## 目前的多进程浏览器

- **浏览器主进程**： 主要负责**界面显示、用户交互、子进程管理、文件储存**等功能
- **GPU进程**：网页、Chrome 的 UI 界面选择采用 **GPU 来绘制**，GPU成为普遍需求
- **网络进程**：面向渲染进程和浏览器进程等**提供网络下载功能**
- **渲染进程（浏览器内核）**：运行在**安全沙箱**中；负责把 HTML、JavaScript、CSS、图片等资源解析为可以显示、交互的页面
- **插件进程**：因为插件易崩溃，所以单独为插件进程来隔离，避免影响浏览器（**部分系统支持安全沙箱**）

![image-20200721193124028](D:\Uttues\Basic-knowledge\浏览器\浏览器相关.assets\image-20200721193124028.png)



### 渲染进程（浏览器内核）

浏览器中**默认每个Tab页面**都有一个**浏览器渲染进程（浏览器内核）**，用于**页面渲染，JS脚本执行，事件处理**等【多线程】

* **GUI渲染线程：**负责浏览器的渲染流程，解析 HTML、CSS，构建 DOM 树和 RenderObject 树，布局和绘制等
* **JS引擎线程（V8引擎|JS内核）**：处理Javascript脚本，等待任务队列中的任务到来**【单线程】**
* **事件触发线程**：控制**事件循环**，执行setTimeOut、鼠标点击时，**将对应事件添加到事件线程中**。当**事件被触发**时，将回调函数添加到 **宏任务|微任务队列**中
* **定时触发器线程**：负责setTimeout、setInterval**计时**（JS是单线程，阻塞会影响计时的准确），计时完成由事件触发线程添加回调到**宏任务队列**中
* **异步http请求线程**：负责异步HTTP请求，当检测到xhr状态变更时，产生对应的状态变更事件（事件触发线程处理回调）
* **（预解析线程）**：预加载HTML 文件中包含的 JavaScript、CSS 等相关文件



### 渲染进程如何与其他进程配合？

1. **在沙箱中运行的渲染进程无法发送网络请求的**，必须通过**进程间通信**，将请求传递给**浏览器主进程**，浏览器主进程交给**网络进程**来处理
2. **网络进程**获取网络资源后，**对响应内容进行解析**（检查字段判断是否跨域等等），检查无误则通过 IPC 将资源提交给**浏览器主进程**
3. **浏览器主进程 **通过 IPC 将资源传递给**渲染进程**
4. **渲染进程**会对资源进行解析、绘制等操作，最终渲染合成为一幅图片（并不负责将图片显示到界面上）
5. **渲染进程**将最终生成的图片提交给浏览器主进程，最终由**GPU进程**负责图片的显示

> （为什么渲染进程不请求网络资源？为什么渲染进程不显示图片？）



### 多进程浏览器如何改进单进程浏览器的缺陷

**不稳定** => **进程隔离**，单个页面、插件的崩溃不会导致整个浏览器崩溃

**不流畅** => 即使Javascript阻塞了某一个渲染进程，也**不会影响浏览器和其他页面**（依然流畅）

​             => 关闭页面，相当于关闭渲染进程，所占用的内存都会被系统回收（解决上述**页面内存泄漏问题**）

**不安全** => 可以将插件进程和渲染进程**运行在安全沙箱中**，即使是恶意程序也无法突破沙箱**直接攻击系统**（！！）



### 多进程浏览器的缺陷

* **更高的资源占用**：每个进程都会包含**公共基础结构的副本（如 JavaScript 运行环境）**，意味着多进程浏览器会消耗更多的内存资源
* **更复杂的体系架构**：浏览器各模块之间**耦合性高、扩展性差**等问题，会导致现在的架构已经很难适应新的需求了

> 目前还没有解决~ 漫长的迭代过程：面向服务架构（SOA）



### 其他进程模块

由于**渲染进程需要安全沙箱的保护**，因此需要把在渲染进程内部涉及到**和系统交互的功能**都转移到**其他进程模块**中去实现

**1、文件储存（浏览器主进程）**：管理Cookie 数据、缓存文件等的储存、文件读写

> 浏览器主进程会维护 Cookie 数据库，当渲染进程通过 JavaScript 来读取 Cookie 时，渲染进程会通过 IPC 将读取 Cookie 的信息发送给浏览器主进程，浏览器主进程读取 Cookie 之后再将内容返回给渲染进程。

**2、网络请求（网络进程）**

网络进程除了发出请求，接受响应之外，还接管了相关检查拦截功能

* 在处理 URL 请求之前，**会检查渲染进程是否有权限请求该 URL**，比如检查 XMLHttpRequest 或者 Fetch 是否是跨站点请求
* **检测 HTTPS 的站点中是否包含了 HTTP 的请求**

**3、用户交互**

渲染进程内部是**无法直接操作 窗口句柄 **的，这是为了**限制渲染进程监控到用户的输入事件**（恶意脚本读取用户输入密码）

> 其他操作系统应用程序可以在窗口句柄上进行绘制和接收键盘鼠标消息。

所以有以下两点改变：

* 渲染进程需要**渲染出位图**，交给**浏览器主进程**显示到屏幕上（GPU进程）
* 操作系统**将用户的输入事件传递给浏览器主进程**，浏览器主进程再根据当前浏览器界面的状态来判断如何调度这些事件：
  * 如果当前焦点位于**浏览器地址栏**中，则输入事件会在浏览器主进程内部处理
  * 如果当前焦点在**页面的区域**内，则浏览器主进程会将输入事件转发给渲染进程

---

目的：限制渲染进程有监控到用户输入事件的能力，所以所有的键盘鼠标事件都是由浏览器主进程来接收的，然后浏览器主进程再通过 IPC 将这些事件发送给渲染进程。



## 浏览器架构如何影响操作系统安全

#### 单进程浏览器 & 浏览器漏洞

**浏览器本身的漏洞**是**单进程浏览器**的主要安全问题，其中最常见的攻击方式是利用**缓冲区溢出**

* 因为**黑客注入的恶意脚本**跟浏览器内核**运行在同一个进程中**，可以**利用漏洞对浏览器、OS实施攻击**
  * **入侵到浏览器进程内部**，读取和修改浏览器进程内部的任意内容
  * **穿透浏览器**，对用户的**操作系统**执行恶意操作（安装恶意软件、监听用户键盘输入信息、读取硬盘文件内容等）
* **单进程浏览器**需要频繁访问或者修改操作系统的数据，**无法用安全沙箱**来保护

---

> **通过浏览器漏洞进行的攻击**不同于XSS攻击：XSS **无法对操作系统进行攻击**，只是将恶意脚本注入到页面中，窃取数据



#### 多进程浏览器 & 安全沙箱

**思想：**

* 在**安全沙箱**里运行渲染进程，从而**隔离渲染进程与操作系统**，渲染进程**无法访问|修改操作系统中的数据**（恶意脚本也不能）
* 在**浏览器内核**中实现**与操作系统交互**的功能。通过**进程间通信（IPC）**实现浏览器内核与渲染进程的交互，从而**满足渲染进程访问系统资源的需求**

---

> ##### 问1：为什么要在安全沙箱里运行渲染进程？
>
> * 因为渲染进程中运行着**网络获取的资源**（不安全，不可信），如果渲染进程中存在**系统级别的漏洞**，那么以上操作就有可能让恶意的站点获取到渲染进程的控制权限，进而又获取操作系统的控制权限，这对于用户来说是非常危险的
> * 下载不运行就无害，所以网络进程、浏览器主进程无需安全沙箱
>
> ##### 问2：什么是安全沙箱？
>
> * 浏览器中的安全沙箱是利用**操作系统提供的安全技术**，其**最小保护单位是进程**
> * 因为**单进程浏览器**需要**频繁访问或者修改操作系统的数据**，所以无法运行在安全沙箱中

---



## Chrome的站点隔离

**过去（标签级的渲染进程）：**一个标签页为一个渲染进程

**问题：**一个标签页中可能包含了多个不同站点的 iframe => **不同站点的iframe运行在同一个渲染进程中**（恶意iframe利用系统漏洞实施攻击）

**现在（iframe级的渲染进程）：严格按照同一站点的策略来分配渲染进程。** **将同一站点（包含了相同根域名、协议的地址）中相互关联的页面放到同一个渲染进程中执行**，从而**将恶意的 iframe 隔离在恶意进程内部**，使得它**无法继续访问其他 iframe 进程的内容**

* 通常情况下两个页面会有两个渲染进程，如果页面里有iframe的话，iframe也会运行在单独的进程中
* 如果两个页面属于同一站点的话，并且从a页面中打开的b页面，那么他们会公用一个渲染进程



## JavaScript为什么是单线程的

作为浏览器脚本语言，JavaScript本质上也是一种GUI变成，主要用途是**与用户互动，处理各种事件以及操作DOM，这决定了它只能是单线程**，否则会带来很复杂的**同步问题**。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，浏览器可能不知道要以哪个线程为准



## Web Worker（HTML5）

为了利用**多核CPU**的计算能力，**HTML5**提出Web Worker标准，**允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM**。

所以，这个新标准**并没有改变JavaScript单线程的本质**。



# 从输入 URL 到页面展示

![img](https://static001.geekbang.org/resource/image/1f/e0/1f4f8c194b02975f6d2848b7b73175e0.png)

![img](https://static001.geekbang.org/resource/image/92/5d/92d73c75308e50d5c06ad44612bcb45d.png)

1、**用户输入**：在浏览器地址栏输入 URL

2、**处理输入信息：**浏览器主进程会解析输入的字符串，判断是**URL**还是**搜索关键字**

- 如果用户输入的是**搜索关键字**则结合**默认搜索引擎**合成新的URL
- 如果用户输入的是**URL**则**检查URL格式**，在URL前**组装协议**（默认http），构成**完整的URL** https://www.baidu.com

> 用户输入完内容回车：（当前页面即将要被替换成新的页面）
>
> * **当前页面**触发 **beforeunload 事件**：数据清理，询问是否离开等**（可以取消导航！）**
> * **浏览器导航栏显示loading状态**，但页面还是**前一个页面**，需要等待**提交文档**阶段，页面内容才会被替换

3、**浏览器主进程**通过**进程间通信（IPC）**将URL请求发送给网络进程处理 ↓↓

---

---

4、网络进程先**检查本地是否缓存了该请求资源**：如果**有且可用**，则直接返回资源给浏览器主进程（200），

5、如果没有，**网络进程开启网络请求流程**，流程如下：

- **域名映射**，获取域名对应的**IP地址和端口号**：静态映射**（DNS缓存）**、动态映射**（递归DNS查询）**
  - 如果没有端口号，HTTP默认80，HTTPS默认443
  - 如果是HTTPS请求，还需要建立TLS连接
- **利用 IP地址 和服务器建立TCP连接**：6个TCP连接，有可能排队/直接建立连接
- 浏览器**构建请求行、请求头**等信息，携带该域名下的Cookie并发送网络请求，服务器处理请求并**返回响应**
  - 扩展：数据包在五层网络模型中的传递

- **网络进程**接收服务端响应，并**解析响应内容**
  - **解析响应头，检查状态码**
    - 300 301重定向：网络进程从响应头的 Location 字段中读取重定向地址，重新发起网络请求
    - 200 继续处理请求
  - **200 检查响应数据类型 Content-Type**
    - 如果是**字节流**类型 application/octet-stream，则将响应提交给**下载管理器**，**导航流程**结束
    - 如果是**文档**类型 text/html，则**通知浏览器主进程**！
  - **根据Connection字段来判断是否断开TCP连接**，Connection: Keep-Alive表示**持久连接**，否则断开TCP连接

---

---

6、**浏览器主进程获取网络进程的通知**，选择 **复用渲染进程 | 创建一个新的渲染进程**

* 默认情况下，每打开一个新页面就会配套**创建一个新的渲染进程**
* 如果页面A中打开页面B，并且而页面A和页面B属于**同一站点**，那么新页面会**复用父页面的渲染进程**

7、【提交文档】浏览器主进程**向渲染进程发出 “提交文档” 的消息**；

8、渲染进程收到消息后，**和网络进程建立**传输的**“数据管道”**来进行文档数据的传输；

9、【确认提交】文档数据传输完成后，**渲染进程返回“确认提交”的消息给浏览器主进程**，表示渲染进程要开始进行页面渲染**（结束导航流程 => 进入渲染阶段）**

---

---

10、**浏览器主进程接收到 “确认提交”** 的消息后，会更新浏览器的当前页面状态（包括安全状态、地址栏的 URL、前进后退的历史状态），更新当前页面，此时的Web页面是空白页（还没渲染完）

---

---

11、渲染进程负责**浏览器的页面渲染**（具体包括文件的**解析**以及**渲染**）

- 构建DOM树 => 样式计算 => 构建布局树 => 布局计算 => 分层 => 生成绘制列表 => 分块 => 光栅化 => 合成与显示

12、一旦页面生成完成，渲染进程会**发送一个消息给浏览器进程**，浏览器接收到消息后，**会停止标签图标上的加载动画。**

---

> 同一站点：根域名和协议相同
>
> **导航过程**：用户发出 URL 请求到**页面开始解析（渲染进程获取文档数据）**的过程
>
> **提交文档：** **浏览器进程**将网络进程接收到的 HTML 数据提交给渲染进程
>
> ---
>
> 如果使用了CDN服务，那么在利用DNS进行**域名解析时**，会得到该域名对应的CNAME记录，**CNAME指向CDN服务商域名**。浏览器需要**再次对获得的CNAME域名进行解析以得到实际的IP地址**（负载均衡算法，获取最近的CDN缓存服务器的IP地址）





## 解析IP地址查找顺序

- 查找的是**浏览器的DNS缓存**
- 查询**系统缓存**：首先检查域名是否在本地 hosts 文件 里,再查系统本地缓存的其他DNS 记录
  - hosts是一个没有扩展名的**系统文件**，作用是将常用的**网址域名**与对应的 **IP 地址**建立一个**关联“数据库 ”**。
- 查找**路由器缓存**
- 查找 **ISP DNS缓存**（ISP 互联网服务提供商，也就是电信网、移动网、联通网）
- **递归 DNS查询**
  - DNS是由**分层的DNS服务器**实现的分布式数据库（也表示一个**允许主机查询分布式数据库**的**应用层协议**）
  - 在专门的DNS服务器上配置**主机到IP地址的映射**，需要时就发送**域名解析请求**。





# 浏览器渲染相关

## 浏览器渲染过程（渲染流水线）

#### （一）构建DOM树  ——  HTML文件（字节数据）=>字符串=>Token=>Node=>DOM

* **HTML文件**中存储的是HTML的**原始字节数据**，根据的指定文件**编码**（例如 UTF-8）将字节数据转换成**HTML字符串**
* **词法分析（标记化）**：根据**HTML规范**，采用**分词器**来将字符串**转换成各种Token标**签，后续会转化为**Node节点**
* **语法分析**（**建树**）：用Node结点构建一个**多叉树的对象模型**，也就是DOM树

---

> **HTML 解析器（HTMLParser）**：将 HTML 字节流转换为 DOM 结构
>
> * HTML 解析器并不是等整个文档加载完成后再解析的，而是**一边从网络进程处获取数据，一边解析数据**
> * 内部维护了一个 **Token 栈结构**，该 Token 栈主要用来**计算节点之间的父子关系**
>   * 开始Token入栈，创建Node节点添加到树中，**Node节点中定义属性和规则**
>   * 文本Token不入栈，创建文本节点添加到树中
>   * 结束Token会使得对应的栈顶开始Token出栈，不创建节点
>
> **HTML规范**中规定了**HTML文件的解析算法**，具体包括**词法分析（标记化）**和**语法分析（建树）**两个阶段
>
> **HTML规范**中的**容错机制**：使用</ br>而不是< br>、表格离散、表单元素嵌套时会忽略内部的form

---



#### （二）样式计算  ——  建树、标准化、计算， 最终得到每个 DOM 节点的样式

1、**构建CSSOM树**：字节数据 => 字符串 => Token => Node =>  CSSOM 【document.**styleSheets**查看】

2、**标准化样式属性值**，转化为**可计算值**：em -> px、red -> #ff0000、bold -> 700

3、**计算出 DOM 树中节点的具体样式**：**继承、层叠**，从最通用的规则开始，**递归遍历CSSOM树**最终确定

* **继承**：默认继承**父节点**的样式属性，父无则用浏览器的默认样式 **UserAgent样式**
* **层叠**：如何合并来自多个源的属性值，得到最终的节点样式

> **这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 window.getComputedStyle 内**



#### （三）创建布局树  ——  布局树只会包含需要显示的节点及其样式信息

* 将 **DOM 树和 CSSOM 树组合为布局树**，有**遍历**并且过滤掉不可见的节点（display: none | head 结点）

![image-20200722150755586](D:\Uttues\Basic-knowledge\浏览器\浏览器相关.assets\image-20200722150755586.png)



#### （四）布局 ——  计算布局树中可见节点在页面中的确切位置和大小（记录在布局树中）



#### （五）分层 ——  对布局树进行分层，并生成图层树 LayerTree【合成层，GPU】

* **渲染引擎会为特定的节点生成专用的图层**，并生成一棵对应的**图层树**
* 因为页面中有很多**复杂的效果**，包括：如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，构建图层树可以更加方便地实现这些效果

> 如果一个节点没有对应的层，那么这个节点就从属于父节点的图层

![image-20200722153932403](D:\Uttues\Basic-knowledge\浏览器\浏览器相关.assets\image-20200722153932403.png)



#### （六）生成绘制列表 —— 将一个图层的绘制拆分成多个小的绘制指令（还没有真的绘制）

* 当图层的**绘制列表准备好之后**，**主线程**会把该**绘制列表提交（commit）给合成线程**来执行绘制操作



#### （七）分块 —— 合成线程会将图层划分为图块（通常是 256x256 或者 512x512）

- **原因**：视口有限，如果一口气绘制出来十分浪费性能，并且不一定会立马被看到

  ![image-20200722155504030](D:\Uttues\Basic-knowledge\浏览器\浏览器相关.assets\image-20200722155504030.png)



#### （八）光栅化 —— 将图块栅格化，转化为位图

**合成线程**会**优先**将**视口附近**的图块经过**栅格化操作**来**转化为位图** 【栅格化：图块 => 位图】

* 渲染进程维护了一个栅格化的**线程池**，所有的图块栅格化都是在**线程池**内执行的

* **GPU**：通常，栅格化过程都会**使用 GPU 来加速生成**，使用 GPU 生成位图的过程叫 **快速栅格化 | GPU 栅格化**
  * 渲染进程把**绘制图块的指令**发送给 GPU进程，由 **GPU 合成**对应的位图，并保存在 **GPU 的内存中**



#### （九）合成和显示  ——  将位图转换成屏幕上的像素

- 一旦所有图块都被光栅化，**合成线程发送绘制图块命令 DrawQuad 给浏览器进程**
- 浏览器进程根据DrawQuad消息**生成页面**，**把页面内容保存到内存中**，并**把这部分内存发送给显卡**
- 显卡就会将页面**合成相应的图像**，保存到**后缓冲区**中【双缓冲】

![image-20200722161913708](D:\Uttues\Basic-knowledge\浏览器\浏览器相关.assets\image-20200722161913708.png)



## 渲染流水线为什么需要 CSSOM

1. 提供给 JavaScript 操作样式表的能力
2. 为布局树的合成提供基础的样式信息



## 什么情况下渲染引擎会为节点创建新的图层

> 什么情况下结点会被提升为一个单独的合成层？【占用内存】

**显式提升**

* 拥有**层叠上下文**属性的元素会被提升为单独的一层
  * HTML根元素< html>
  * **position为 absolute|relative **并且**设置了z-index属性（不为auto）**
  * **position为 fixed|sticky **
  * flex容器、grid容器的子元素，且 z-index 值不为 auto
  * 元素的 **opacity 值 < 1**
  * 元素的 transform|filter 值不为 none
  * **will-change 值**设定为**任一属性并且该属性为非初始值**（opacity、transform、top、left、bottom、right）

* **需要剪裁的地方**，渲染引擎会为**文字部分**单独创建一个层，如果出现**滚动条**，滚动条也会被提升为单独的层

---

**隐式合成**：**z- index较低** 的节点被提升为**单独的图层**后，所有**层叠等级比它高的节点都会**成为一个单独的图层

* **隐式合成隐藏着巨大的风险**，**层爆炸**：可能会增加上千个不必要的图层，**增加内存压力**，甚至导致**页面崩溃**
* **解决方案**：打破 overlap 的条件，让**其他元素不要和合成层元素重叠**。也就是当我们**使用3D硬件加速提升动画性能**时，最好**给元素增加一个z-index属性**，**人为干扰合成的排序**，可以有效减少chrome创建不必要的合成层，**提升渲染性能**

---

> [层叠上下文 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context)
>
> 页面是个二维平面，但是**层叠上下文**能够让 HTML 元素具有**三维概念**
>
> 拥有层叠上下文的元素**按照自身属性的优先级**分布在垂直于这个二维平面的 z 轴上
>
> ![image-20200722154716125](D:\Uttues\Basic-knowledge\浏览器\浏览器相关.assets\image-20200722154716125.png)





## 回流、重绘、直接合成相关

### 回流、重绘 | 直接合成（GPU加速）

**浏览器渲染过程：**

构建DOM树 => 样式计算 => (构建布局树 => 布局计算) =>  分层  => 生成绘制列表 => 分块 => 光栅化 => 合成与显示

![image-20200722170234462](D:\Uttues\Basic-knowledge\浏览器\浏览器相关.assets\image-20200722170234462.png)

---

#### 回流

* **布局树** 因为**元素的几何属性、布局、隐藏**等改变而需要**重新构建**【触发**重新布局**，重新计算节点位置和大小】

![image-20200722171059363](D:\Uttues\Basic-knowledge\浏览器\浏览器相关.assets\image-20200722171059363.png)



#### 重绘

- **更新元素的绘制属性**，只影响元素的**外观、风格，不会影响布局**【可以**直接跳过 布局、分层 阶段**】

![image-20200722171115749](D:\Uttues\Basic-knowledge\浏览器\浏览器相关.assets\image-20200722171115749.png)



#### 直接合成【GPU加速】

https://juejin.im/post/5da52531518825094e373372

* **直接合成**：更改**不需要布局、绘制**的属性，则**会直接执行非主线程上的合成操作**，这个过程叫做**直接合成**
  * **比如：变形、渐变、动画等特效**
  * 在**合成**时，会**跳过布局、绘制**，直接进入**非主线程处理**的部分，即**直接交给合成线程处理**【GPU线程池，**GPU加速**】
* **应用**：使用**CSS 的 transform** 实现动画效果，用 CSS3 的**will-change**: **transform** 触发合成GPU加速等

![image-20200722171738726](D:\Uttues\Basic-knowledge\浏览器\浏览器相关.assets\image-20200722171738726.png)



---

##### GPU硬件加速|合成层的优点

- **充分发挥GPU擅长处理位图数据的优势**： **合成线程**生成位图时**调用线程池**，**使用GPU进行加速生成**【比CPU处理快，虽然好像其他的也是GPU】
- 合成线程**没有占用主线程的资源**，即使主线程卡住了，效果依然能够流畅地展示
- **发生改动时**可以直接跳过布局、绘制等流程，**避免引起回流重绘**
- 层独立，避免自己的改动影响到其它图层

##### GPU硬件加速|合成层的缺点

1. 合成层占用会内存
2. 处理不当可能引起层爆炸（处理不当：隐式合成）



### 常见引起回流的属性和方法

> 特点：会改变元素几何信息：**位置/尺寸大小**

1. 添加或者删除可见的DOM元素
2. 元素尺寸改变——边距、填充、边框、宽度和高度
3. 内容变化，比如用户在input框中输入文字
4. 浏览器窗口尺寸改变——resize事件发生时
5. **获取 offsetWidth、scrollTop、clientTop等属性**，会**同步**重新进行**样式计算和布局**
   - 【强制同步布局】【布局抖动预警】
6. **设置 style 属性的值 /** 调用了 **getComputedStyle** 方法（**每个都会造成回流**）

---

#### 强制同步布局

**正常情况下布局操作**引起样式、布局的重新计算是**异步完成**，目的是为了避免占用主线程时间

![img](https://static001.geekbang.org/resource/image/32/c9/32b6a645646f99fc3517fb0b5e003cc9.png)

**强制同步布局**：**指 JavaScript 强制将计算样式和布局操作提前到当前的任务中**

```js
function foo() {
    let main_div = document.getElementById("mian_div")
    let new_node = document.createElement("li")
    let textnode = document.createTextNode("time.geekbang")
    new_node.appendChild(textnode);
    document.getElementById("mian_div").appendChild(new_node);
    //前面刚操作完节点，此时的offsetHeight还是老的数据，所以需要重新布局 => 强制同步布局
    console.log(main_div.offsetHeight)
}
```

![img](https://static001.geekbang.org/resource/image/ce/d9/ce951be7a38e2ef1a9a23a1c7e84b1d9.png)

#### 布局抖动

布局抖动指的是：在一次 JavaScript 执行过程中，**多次**执行强制布局和抖动操作（for循环中）





### 常见引起重绘的属性和方法

![img](https://image.fundebug.com/2019-01-03-9.png)



### 如何减少回流、重绘

- **将频繁重绘或者回流的节点提升为合成图层**：不占主线程资源，不回流重绘【**transform 替代 top 等属性**】
- **使用 visibility 替换 display: none** （前者只会引起重绘，后者会引发回流、重绘）
- 对于 **resize、scroll** 等采用**防抖/节流**处理

- **不要使用 table 布局**，可能很小的一个小改动会造成整个 table 的重新布局

- 动画实现的速度的选择，**动画速度越快，回流次数越多**；可以选择使用 requestAnimationFrame / 合成动画

---

- 批量DOM操作：使用**DocumentFragment** 来合并多次DOM节点的增删操作
- 批量内联样式操作：使用**类名class来合并样式**，避免逐项直接设置style
- 避免在**for循环**里 **读取节点属性offsetWidth|反复调用getComputedStyle()**，会引起**布局抖动**（多次**强制同步布局**）





## 渲染页面时有哪些常见不良现象

* **无样式内容闪烁**：在CSS加载之前，先呈现了HTML【不同浏览器渲染机制相关】

* **白屏**：对于 **DOM+CSSOM => 布局树** 的浏览器渲染机制
  * 将**CSS部分放在HTML尾部**，加载慢
  * 把**js文件放在头部**阻塞其后组件的下载，出现白屏问题





## Javascript脚本相关

### script标签中async和defer的区别

* **无defer、async**：**立即加载并执行**指定的脚本，**加载和执行**都阻塞当前DOM加载
* **defer**：**异步加载，延时执行**【有顺序】
  * 异步加载不阻塞DOM树，**DOM解析完|DOMContentLoaded事件触发前**执行 defer-script脚本
* **async**：**异步加载，加载好立即执行**【无顺序】



### 为什么Javascript操作DOM很慢？

**DOM操作** 是属于**GUI渲染线程**所控制的，而 **执行JS** 又是 **JS 引擎线程**中的东西（线程互斥）

*  **JS 操作 DOM** **涉及到了两个线程之间的通信**，存在**性能上的损耗**，线程上下文切换也有代价
* 操作 DOM 可能还会带来**重绘回流**的情况，所以也就导致了性能上的问题。



### JavaScript 如何阻塞 DOM 树渲染

#### 1、下载 JavaScript 脚本会阻塞 DOM 树

**存在问题**：下载耗时，受到网络环境、JavaScript 文件大小等因素的影响。

**Chrome 浏览器的优化 —— 预解析**：当**渲染引擎**收到**HTML字节流**之后，会开启一个**预解析线程**，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，一旦发现相关文件，**预解析线程会提前下载这些文件**。

**性能优化策略：**

* 提高加载速度：使用 CDN 来加速 JavaScript 文件的加载（网络），压缩 JavaScript 文件的体积（文件大小）
* **异步加载脚本**：如果 JavaScript 文件中**没有操作 DOM 相关代码**，可以设置为**异步加载**（async 或 defer）

#### 2、执行 JavaScript 脚本会阻塞 DOM 树（线程互斥）

**原因：**由于JavaScript是可操纵DOM的，如果在修改元素属性的同时渲染界面（线程同时运行），**就可能无法预料渲染线程输出的效果**

* 先JS：为了**防止js操作了dom**等

**表现**：为了防止**渲染出现不可预期**的结果，浏览器设置**GUI渲染线程与JS引擎为互斥**的关系，**当解析到script标签时，执行内嵌的Javascript代码，GUI渲染线程会被挂起**（HTML 解析器暂停工作），**GUI更新操作**则会被保存在一个队列中等**到JS引擎线程空闲**时立即才被执行。

**性能优化策略：**

* 将 script 标签**放在 body 标签底部**
* 为script标签指定 **async 或 defer**来延迟脚本
  * **async**表示js加载时不会阻塞DOM解析，但会在下载完成后立刻执行（阻塞）
  * **defer**则会在下载完成并且整个文档解析完成、DOMContentLoaded事件被触发前开始执行

#### 3、执行 JavaScript 会导致 CSSOM 的构建阻塞 DOM 树

执行Javascript脚本时，会被 **在Script标签前面引入的CSS** 阻塞，只有CSSOM构建完毕后，执行JavaScript【间接阻塞了DOM树的构建】

**原因**：Javascript可以**修改样式**，而**不完整的CSSOM是无法使用的**。所以浏览器会保证在JavaScript文件执行之前，加载完并完成CSSOM的构建

* 浏览器通常会认为**该脚本依赖于脚本前引入的样式的渲染结果**， 也就更倾向于延迟脚本的执行（直到样式渲染结束）

* **原本DOM和CSSOM的构建是互不影响**，**并行构建**

![image-20200723122127906](D:\Uttues\Basic-knowledge\浏览器\浏览器相关.assets\image-20200723122127906.png)

---

> 因此要尽量**避免JS进行巨大计算，导致执行时间过长**，会造成**页面的渲染不连贯**，或产生卡顿的感觉。
>
> 提高**首屏渲染速度**：
>
> * 尽量不在首屏加载JavaScript文件，将 script 标签**放在 body 标签底部**
> * 或者是为script标签指定 **async 或 defer**来延迟脚本





### JavaScript 如何延迟 DOMContentLoaded 触发

1、JavaScript 如何阻塞 DOM 树渲染

2、脚本可能修改 DOM，甚至执行 `document.write` 操作



## CSS加载是否会阻塞dom树渲染

- **CSS加载**不会阻塞DOM树解析（CSS是由**单独的下载线程异步下载**的）
- JavaScript 脚本依赖其前面引入的样式表，所以**执行 JavaScript** 会导致 CSSOM 的构建阻塞 DOM 树
- CSS**加载**和CSS规则树的**构建**会**阻塞布局树的构建**（因为**render树需要CSS信息**）



## 页面生命周期

**DOMContentLoaded**：**DOM树，也就是页面元素加载完毕**，此时可以正常**交互**，比如滚动，输入字符等；**无需等待样式表等**的完成加载

* jQuery 中： **`$(document).ready()`** 监听的就是 DOMContentLoaded 事件

**load** ：页面上**所有的资源（图片，音频，视频等）加载完成**，可以获取图像大小。

* jQuery 中：**`$(document).load() / window.onload()`** 监听的是 load 事件。

**beforeunload**：用户**即将离开**（开启新的导航流程/关闭页面）

**unload**：用户几乎已经离开了，但是仍然可以启动一些操作，比如发送统计数据。





## 图像显示的原理/显卡的作用（合成展开）

* **显示器**：显示器**每 1/60 秒**就去读取**显卡前缓冲区**中的图像，并将读取的图像**显示到显示器**上（显示器的刷新频率：60Hz）
* **显卡**：显卡接收到浏览器主进程**传来的页面**后，根据页面**合成新图像**，并将图像**写入后缓冲区**中，（一旦显卡把合成的图像写到后缓冲区）此时系统会自动**调换前后缓冲区的位置**，使得显示器能读取到最新合成的图像

* 通常情况下，显卡的更新频率和显示器的刷新频率是一致的 => 意味着要实现**流畅的动效**，渲染引擎需要每秒更新 60 张图片给显卡。





## 分层、分块、合成

### Chrome 为什么要引入分层、合成

如果没有采用分层机制，**从布局树直接生成目标图片**，不管页面变化大或小，都会“牵一发而动全身”地触发整个图层的回流重绘，严重影响了页面的渲染效率。

* **分层：将素材分解为多个图层的操作**

在分层的基础上引入合成，这样子合成器只需要将两层的变化合并即可（可能只有某层的小变化）

- **合成：将这些图层合并到一起的操作**（显卡操作很快）

---

> 生成图片帧的方式：回流、重绘、合成。
>
> & **合成操作的路径**很短，**不需要触发布局和绘制**两个阶段，**计算样式（CPU）**后直接进入**合成线程**的操作，主要是分块、光栅化、合成与显示；并且这一阶段为**非主线程不阻塞**，系统会**调用GPU来进行加速**，所以合成的**效率很高**



### 浏览器如何实现分层、合成机制

**分层**：图层树中的每个节点都对应着一个图层

**绘制（生成绘制列表）**：每一个图层都会有自己对应的一组绘制列表

**分块、光栅化**：在此基础上进行**图块划分**，优先对靠近视口的图块做光栅化处理，生成位图（GPU线程池）

**合成与显示：**合成线程再将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。



### 浏览器在分块操作上的优化

- **优先绘制靠近视口的图块**
- 在首次合成图块的时候使用一个**低分辨率的图片**，提高**纹理上传的速度**
  - 在首次显示页面内容时，显示低分辨率的图片，当正常比例的网页内容绘制完成后，再替换掉
  - **纹理上传**：从**计算机内存上传到 GPU 内存**的操作会比较慢，





# 前端的动画效果

- JavaScript
  - 定时器 setTimeout 和 setIterval 来间隔来改变元素样式
  - requestAnimationFrame：浏览器用于**定时循环操作**的一个接口，主要用途是**按帧对网页进行重绘**。
- CSS3：transition 和 animation；
- HTML5：使用HTML5提供的绘图方式（canvas、svg、webgl）；



### 如何用 JavaScript 实现高性能的动画——requestAnimationFrame





渲染进程任务调度系统

requestAnimationFrame 与 setTimeOut 的区别

Performance 标签



主线程维护了一个普通的消息队列和一个延迟消息队列，调度模块会按照规则依次取出这两个消息队列中的任务，并在主线程上执行。



### 动画卡顿为什么会出现？

* 动画大量**占用内存**，可能会导致 渲染引擎**生成某些帧（更新的图片）的时间过久**，图像**传送给显卡不及时**；但此时**显示器**还是**以不变的频率去刷新**，此时就会出现**卡顿**，也就是明显的**掉帧**现象。
  * 用户很容易观察到那些丢失的帧

- 因此要解决动画卡顿问题的核心，就是需要解决**每帧生成时间过久的问题**【Chrome的优化：引入分层与合成机制】



### 为什么主线程卡住了，CSS 动画依然能执行

合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。



### 为什么CSS 动画比 JavaScript 动画高效

* 触发元素形成合成层，避免回流重绘
* Javascript与GUI渲染线程是互斥关系，Javascript动画操作DOM对性能影响比较大（回流重绘、线程切换）







# 性能优化相关

## Chrome开发者工具

- 与**调试页面相关**的有 Elements 面板、Sources 面板、Console 面板等。
- 与**性能相关**的有网络面板、Performance 面板、内存面板等；

![img](https://static001.geekbang.org/resource/image/c5/82/c5eb9603e79547ae3d815254e24d4782.png)



## 网络阶段

- **请求排队**：请求不能立即执行
- **代理协商**：**代理服务器**连接协商所用的时间，如果用了代理服务器才有
- **建立连接**：和服务器建立连接（TCP+SSL握手）
- **发送请求**：网络进程将请求数据发送给网络（请求数据放在浏览器缓冲区中）
- **第一字节时间 TTFB**：**网络请求被发起**到从服务器**接收到第一个字节**的时间，反映服务端响应速度的重要指标
- **资源加载时间**：从第一字节时间到接收到全部响应数据所用的时间



### 导致网络请求处于排队状态的原因

1. 页面中的**资源是有优先级的**，通常非核心资源遇到核心资源（JS、HTML、CSS）时，需要“让路”
2. **队头阻塞（长链接）**：并发连接不够用
3. **网络进程在为数据分配磁盘空间**时，新的 HTTP 请求也需要短暂地**等待磁盘分配结束**。



### 导致第一字节时间过久的原因

1. **服务器生成页面数据的时间过久**
2. **网络原因**：低带宽服务器；联调用户访问电信服务器
3. 发送请求头时带上了**多余的Cookie信息**：服务器接收到这些 Cookie 信息之后可能需要对每一项都做处理



### 网络阶段的性能优化

1. **减少请求排队时间**：域名分片（过时了）；**把站点升级到 HTTP2**
   - 域名分片：把1 个站点下面的资源放在多个域名下（6*n个连接）
   - HTTP2 采用多路复用来消除HTTP/1.1中队头阻塞的问题
2. **减少第一字节时间**
   - 提高服务器的处理速度
   - CDN缓存静态文件 + 利用浏览器缓存技术（解决网络问题）
   - 发送请求时就去尽可能地减少一些不必要的 Cookie 数据信息



## 首屏、白屏时间 及其计算方法

**白屏时间** =  浏览器**出现第一个元素** - 地址栏输入网址后回车【提交文档+**解析白屏（真的白屏）**】

* 解析白屏时间过久，就会影响到用户体验

**首屏时间** =  浏览器**首屏内容渲染完成** - 地址栏输入网址后回车

---

**白屏时间计算方法：** 

* 在head标签**头尾插入两个script计算**时间差
  * 通常认为浏览器**开始渲染 `<body>` 或者解析完 `<head>`** 的时间是白屏结束的时间点
* performance api

**首屏时间计算方法：** 

* **首屏模块标签标记法**：在此元素后面加入 `script` 计算时间（假定当解析到某个元素时相当于首屏完成）
* **统计首屏内加载最慢的图片/iframe**
  * 通常首屏中**加载最慢**的就是图片或者 iframe 资源，因此可以理解为当图片或者 iframe 都加载出来了，首屏肯定已经完成了。
  * 浏览器对每个页面的 **TCP 连接数**有限制，使得并不是所有图片都能立刻开始下载和显示。
  * 方法：监听首屏内**所有图片的 onload 事件**，获取 **onload 最大值**，并用这个值减去 navigationStart 即可获得近似的首屏时间



## 用户可交互时间

**用户可交互时间：** = domContentLoadedEventEnd - navigationStart

* 当domContentLoaded事件触发时，意味着**页面元素加载完毕**，可以正常**交互**





## 影响页面展示的因素以及优化策略 / 首屏、白屏优化

### 阶段一：主进程接收到渲染进程“确认提交”的消息前【展示前一个页面】

#### 浏览器对URL进行DNS解析

**【DNS Prefetch / DNS预解析】**：**提前解析之后可能会用到的域名**并缓存结果 | 缓存**访问过的**页面域名

- **自动解析：**遇到`a`标签，**浏览器会自动将`href`中的域名解析为IP地址**，解析过程与用户浏览网页**并行处理**的。
  - 为了确保安全性，在`HTTPS`页面中不会自动解析

* **手动解析**：可以在在**包含有url的标签**上添加**rel="dns-prefetch"来触发浏览器的dns预解析**（img）

#### 浏览器与服务器进行TCP连接

#### 客户端请求、服务端响应

> 关键资源：能阻塞网页首次渲染的资源称为关键资源（Javascript、html、css，图片音频等则不是）
>
> 1. 减少关键资源的个数：内联 JavaScript 和 CSS、Webpack打包、async|defer
> 2. 减少关键资源的大小：
> 3. 减少请求关键资源所需的RTT：

* **减少请求排队时间**：域名分片（过时了）；**把站点升级到 HTTP2**（采用多路复用来消除HTTP/1.1中队头阻塞的问题）
* **减少请求次数**【减少关键资源个数】
  * **资源合并**：内联Javascript、css文件；**webpack**打包；**雪碧图**合并小图（background-position定位）
  * **前端缓存**：Service Worker Cache、内存缓存、磁盘缓存（HTTP Cache  -  强缓存）
  * **本地存储**：cookie、localStorage、sessionStorage

* **减少第一字节时间**
* **缩小响应体积 | 减少资源加载时间**【减少关键资源大小】
  * **资源合并**：**Gzip**、去除注释、**代码**丑化压缩、**图片**压缩、CSS的Tree shaking去除冗余代码
  * **在不同分辨率下保存多个版本的光栅图像**，能用小的就不用大的图
  * 选用正确格式的图片
    * PNG：无损格式，压缩率一般，支持透明背景，常用于透明图片或者Icon等。
    * **JPG**：有损格式，压缩率较好，常用于复杂的大图，不支持透明背景。
    * SVG：矢量图形，可编程。在各分辨率下不失真，但是渲染复杂图形较消耗性能。常用于简单图形。
  * WEBP：无损格式，相较于PNG和JPG来说，压缩率更好，同时支持透明背景，但兼容性差
  
* **CDN加速：**CDN是依靠部署在各地区的边缘服务器，主要的关键技术是**内容存储和分发技术**，**达到用户就近获取内容，降低网络拥塞，提高用户访问速度和命中率的目的**
* **减少请求中多余的Cookie信息**：1. 降低请求体积、2. 减少服务端处理请求的时间

### 阶段二：渲染进程创建空白页面【解析白屏、首次渲染】

> **白屏阶段**：解析 HTML、下载 CSS、下载 JavaScript、生成 CSSOM、执行 JavaScript、生成布局树、绘制页面
>
> **影响白屏时间的因素**：服务端性能、网络、前端页面结构设计

#### 页面渲染

- **服务端渲染**：能够有效加快首屏渲染速度（SEO优化；对服务器有压力）


* **客户端请求、服务端响应**：减少请求次数、减小响应体积、CDN加速 ……
* 前端页面结构设计，**避免 JS | CSS 阻塞DOM树**

- **避免回流与重绘**：合成层、合成动画、独立图层抽取（避免绘制不需要重新绘制）
- **懒加载**：用到时再加载

---

- **减少 JavaScript 脚本执行时间**（长时间霸占主线程，阻塞其他线程）：**任务分解、WebWorker**
  - **WebWorker**：可以把一些**和 DOM 操作无关**且**耗时**的任务放到 Web Workers 中去执行
- **避免强制同步布局、避免布局抖动**：offsetWidth、scrollTop、clientTop、getComputedStyle()
- **CSS合成动画**：will-change
- **避免频繁的垃圾回收**：JavaScript 使用了**自动垃圾回收机制**，在一些函数中**频繁创建临时对象**会触发垃圾回收器频繁地去执行垃圾回收策略 => 优化存储结构



### 阶段三：从首次渲染到完整页面的绘制阶段【白屏-首屏】

> **影响首屏时间的因素**：白屏时间、资源下载速度（跟白屏差不多？懒加载）
>
> 关键资源：能阻塞网页首次渲染的资源称为关键资源（Javascript、html、css，**图片音频等则不是）**

---

----







# Chrome  V8 垃圾回收算法

Chrome 浏览器所使用的 V8 引擎就是采用的**分代回收策略**。

思想：通过区分**「临时」与「持久」对象**：多回收「临时对象区」（**新生代**younggeneration），少回收「持久对象区」（**老生代** tenured generation），**减少每次需遍历的对象，从而减少每次GC的耗时。**



### **V8的内存限制**

**在node中**javascript能使用的内存是有限制的.

1. 32位系统下约为0.7GB【新生代内存大小为16MB，老生代内存大小为700MB】
2. 64位系统下约为1.4GB【新生代内存大小为32MB，老生代内存大小为1.4GB】

> 新生代平均分成两块相等的内存空间，叫做semispace

这个限制在node启动的时候可以通过传递--max-old-space-size 和 --max-new-space-size来调整，如：

```
node --max-old-space-size=1700 app.js //单位为MB
node --max-new-space-size=1024 app.js //单位为kb
复制代码
```

**上述参数在V8初始化时生效，一旦生效就不能再动态改变**

#### V8限制堆的大小的原因（内存限制的原因）

表层：V8最初为浏览器而设计，不太可能遇到用大量内存的场景

深层：V8的垃圾回收机制的限制。内存越大垃圾回收耗时越长，而垃圾回收会引起JS线程阻塞（暂停执行）



### **V8的分代回收（Generation GC）**

V8垃圾回收策略主要**基于分代式垃圾回收机制**：按对象的存活时间对内存进行分代，分别用施以更高效的算法

**V8的内存分代：**（V8堆大小 = 新生代 + 老生代）

* **新生代内存**：存活时间较短的对象，再对堆内存**一分为**二：From空间（使用中）、To空间（空闲）
* **老生代内存**：存活时间较长或常驻内存的对象：

![image-20200423094142935](C:\Users\45859\AppData\Roaming\Typora\typora-user-images\image-20200423094142935.png)

#### **V8新生代算法（Scavenge算法）**

新生代中的对象主要通过**Scavenge算法**进行垃圾回收，而在Scavenge的具体实现中，主要采用了Cheney算法

**Cheney算法**是**采用复制方式**实现的垃圾回收算法：

- 分配对象空间时，先是在**From空间**中进行分配
- 进行垃圾回收时：将存活对象在两个semispace空间之间进行复制
  - From：释放非存活对象空间；将存活对象复制到To空间中，
  - 完成复制后，From空间和To空间的角色发生对换（原From空间释放后变为To;To空间在复制存活的对象后变为From空间）

**Scavenge的特点：牺牲空间换取时间**（适合新生代，但无法大规模地应用到所有的垃圾回收中）

- **缺点**：**只能使用堆内存中的一半**【由划分空间和复制机制所决定】 =>  无法大规模地应用到所有的垃圾回收中
- **优点**：**只复制存活的对象**，耗时短【对于生命周期短的场景，存活对象只占少部分】 => 非常适合新生代



**晋升:**	对象从新生代中移动到老生代中的过程

* 当一个对象**经过多次复制依然存活**时，它会被认为是生命周期较长的对象，随后会被移动到老生代中，即晋升
* **单纯的Scavenge过程中**：From空间中的存活对象会被复制到To空间中去，然后翻转From空间和To空间
* **但在分代式垃圾回收前提下**：From空间中的存活对象**在复制到To空间之前需要进行检查**，完成对象部分晋升

**晋升条件**

* 对象是否经历过Scavenge回收（To空间将变成From空间，在这个空间中完成内存分配）
* To空间的内存占用比超过25%限制**（影响后续的内存分配）**

![image-20200423101216627](C:\Users\45859\AppData\Roaming\Typora\typora-user-images\image-20200423101216627.png)



#### V8老生代算法（Mark-Sweep && Mark-Compact 结合）:

> 为什么不使用Scavenge：存活对象较多，复制效率很低；浪费一半空间

**Mark-Sweep 标记清除**

- 标记阶段：遍历堆内对象并且做标记
- 清除阶段：清除未标记对象

**Mark-Sweep && Scavenge 的区别**

* **Scavenge复制活着的对象（活的少效率高）；Mark-Sweep清理死亡对象（死得少效率高）**
  * **这是两种回收方式能高效处理的原因**

* **Mark-Sweep**不将内存空间划分为两半，所以**不存在浪费一半空间的行为**。



> 下图为Mark-Sweep在老生代空间中标记的示意图，**黑色部分标记为死亡对象**
>
> ![image-20200423101857493](C:\Users\45859\AppData\Roaming\Typora\typora-user-images\image-20200423101857493.png)



**Mark-Sweep 缺陷：标记清除回收厚，内存不连续**，而内存碎片会对后续的内存分配造成问题

* 需要分配一个大对象，当前碎片空间都无法完成此次分配，就会**提前触发垃圾回收**，而这次回收是**不必要**的



**Mark-Compact 标记整理**：为了解决Mark-Sweep的内存碎片问题（在Mark-Sweep的基础上演变而来）

* 对象在标记为死亡后，**在整理的过程中，将活着的对象往一端移动，移动完成后，直接回收边界外的内存。** 



> 下图为Mark-Compact完成标记并移动存活对象后的示意图，白色格子为存活对象，深色格子为死亡对象，浅色格子为存活对象移动后留下的空洞
>
> ![image-20200423102257716](C:\Users\45859\AppData\Roaming\Typora\typora-user-images\image-20200423102257716.png)



**Mark-Sweep、Mark-Compact、Scavenge三种主要垃圾回收算法的简单对比**

| 回收算法     | Mark-Sweep   | Mark-Compact | Scavenge           |
| ------------ | ------------ | ------------ | ------------------ |
| 速度         | 中等         | 最慢         | 最快               |
| 空间开销     | 少（有碎片） | 少（无碎片） | 双倍空间（无碎片） |
| 是否移动对象 | 否           | 是           | 是                 |

在取舍上，V8主要使用Mark-Sweep【因为Mark-Compact需要移动对象，执行速度并没有很快】

- 在**空间不足以对从新生代中晋升过来的对象进行分配时，使用Mark-Compact**



### **增量式标记回收（Incremental Marking）**

**全停顿（stop-the-world）**：为了避免 **js应用逻辑与垃圾回收器看到的不一致**，所以**垃圾回收的3种基本算法都会挂载当前应用逻辑**。等到执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为全停顿。

- 在V8的分代式垃圾回收中，一次**小垃圾回收只收集新生代（容量小，存活对象少）**，全停顿的影响不大
- 但V8的老生代**容量配置大，存活对象多**，全堆垃圾回收的**标记、清理、整理**等动作造成的**停顿就会比较可怕**



为了**降低全堆垃圾回收造成的停顿时间**，V8将传统的标记方式（一口气标记完）改成**增量标记**

**增量标记：**将原本的标记阶段拆分为许多小“步进”，标记一会就让JS应用逻辑执行一会（交替执行直到标记完成）

- V8在经过增量标记的改进后，垃圾回收的最大停顿时间可以**减少到原本的1/6左右**



> V8后续还引入了**延迟清理**、与**增量式整理**：让清理与整理动作也变成增量式的。
>
> 同时还计划引入**并行标记**与**并行清理**，进一步**利用多核性能**降低每次停顿的时间。



## 减少垃圾和回收对性能的影响:

- 让垃圾回收尽量少地进行，尤其是**全堆垃圾回收**（主要靠v8自己的优化机制）.
- **避免内存泄露**，让内存及时得到释放。这部分是开发者需要注意的



## 垃圾回收优化

* **数组优化：**优先使用 arr.length = 0 的方式来清空数组，arr = [] 会将原数组变成内存垃圾
* **对象尽量复用：**不用的对象尽可能**手动将对象设置为 null**



## 内存泄漏

### 什么是内存泄漏？

**内存泄漏：没有及时释放不再用到的内存。**

**内存泄漏的危害**：内存占用越来越高，轻则影响系统性能变慢，延迟大等 ，重则导致进程崩溃



### 内存泄漏的监测方法

- 打开 Chrome 浏览器的 **开发者工具**，使用快捷键 `F12` 或者 `Ctrl+Shift+J` 
- 选择 **Performance选项卡**(老版为Timeline) ，在 Capture 选项中，只勾选 Memory。
- 点击最左边的 **`Record` 按钮**，**访问**某网页，当网页加载完成后，点击 **`Stop`**，等待分析结果。
- **在 `Chart View` 上寻找内存急速下降的部分**，查看对应的 **Event Log**，可以从中找到 **GC 的日志**。

![image-20200423122955517](C:\Users\45859\AppData\Roaming\Typora\typora-user-images\image-20200423122955517.png)



### 内存泄露的常见原因

* **意外的全局变量**

  1. 函数内某个变量没有声明，JS会默认将其转为全局变量（页面关闭前都不释放）

  * **应对方法：**使用**严格模式**可以避免

  ```js
  function foo(){
      bar=2
      console.log('bar没有被声明!')
  }
  ```

* **存在对已清空DOM的引用**

  1. 为了存取方便会将DOM结点保存在数据结构中，若不需要时没有及时**解除引用**，则会造成内存泄露
  2. DOM 节点绑定了事件，但是在**移除时没有解除事件绑定**，那么仅仅移除 DOM 节点也是没用的

  * **应对方法**：**WeakSet & WeakMap**

  ```js
  var element = {
    shotCat: document.getElementById('shotCat')
  };
  document.body.removeChild(document.getElementById('shotCat'));
  // shotCat 节点依然留存在内存中
  ```

很多时候,为了方便存取,经常会将 DOM 结点暂时存储到数据结构中.但是在不需要该DOM节点时,忘记解除对它的引用,则会造成内存泄露.

* **定时器中的内存泄漏**

  1. 如果没有及时清除**定时器 setInterval**，则其**内部**的变量/DOM结点**无法释放**，会引发性能问题
  2. setTimeout 计时结束后其回调里面引用的对象占用的**内存是可以被回收（但是如果出现闭包则凉凉）**

  ```js
  var someResource = getData();
  setInterval(function() {
      var node = document.getElementById('Node');
      if(node) {
          node.innerHTML = JSON.stringify(someResource));
      }
  }, 1000);
  ```

* **不规范使用闭包**：闭包中存在**循环引用**

  * 应对方法：不要将a.fn = bar

  ```js
  function foo() { 
    var a = {}; 
    function bar() { 
      console.log(a);  
    }; 
    a.fn = bar;  //a引用bar
    return bar;  //bar引用foo.a
  };
  ```



### 避免内存泄漏的策略

1. **减少不必要的全局变量**，或者生命周期较长的对象，及时对无用的数据进行垃圾回收（**手动赋值为 null**）
2. 注意程序逻辑，避免“**死循环**”之类的 ；
3. 避免创建过多的对象，原则：**不用了的东西要记得及时归还。**
4. **减少层级过多的引用**，可以用WeakSet、WeakMap来存储DOM结点的引用
5. 清除定时器



### 闭包与内存泄漏

```js
function bindEvent() {
  var div = document.createElement('div')
  div.onclick = function() {}
}
```

闭包会维持函数内部的变量，使其得不到释放，**解决方法**：

- **将事件处理函数定义在外部**
- 在定义事件处理函数的外部函数中，**删除对 dom 的引用**
- **解除闭包**

```js
// 将事件函数定义在外边
function onClickEvent() {
  // ...
}

function bindEvent() {
  var div = document.createElement('div')
  div.onclick = onClickEvent
}
```

```js
// 删除对 dom 的引用
function bindEvent() {
  var div = document.createElement('div')
  div.onclick = function() {
    // ...
  }
  div = null
}
```

