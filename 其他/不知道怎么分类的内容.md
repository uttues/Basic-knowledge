# 前端的动画效果

- JavaScript
  - 定时器 setTimeout 和 setIterval 来间隔来改变元素样式
  - requestAnimationFrame：浏览器用于**定时循环操作**的一个接口，主要用途是**按帧对网页进行重绘**。
- CSS3：transition 和 animation；
- HTML5：使用HTML5提供的绘图方式（canvas、svg、webgl）；



# 图片格式相关

## 点阵图 & 矢量图

**点阵图/光栅图** 

* 光栅图由**二维的像素网格**组成，每个像素存储了**颜色和透明**度的值，**放大会失真**
  * 【压缩方法：减少每个像素所需的位数】
* 图片格式：**JPEG(jpg)、GIF和PNG**

**矢量图**

* **矢量图**由一些**线条、形状和路径点**组成，图片信息保存在精确的**绘画指令**中，独立于像素，**放大不失真**
* 图片格式：**SVG**，十分适合**Retina屏**



## 常见图片格式及其特点

**点阵图 & 矢量图**

* JPEG(jpg)、GIF、PNG、WebP是**点阵图**，放大会失真【**二维的像素网格**组成，存储**颜色和透明**度】
* SVG是**矢量图**，本质上是一种**基于XML**的矢量文件类型

**无损压缩 & 有损压缩**

* 有损压缩：**JPEG**（压缩率高）
* 无损压缩：**PNG、GIF** （GIF只支持256种颜色，体积小）
* SVG、WebP **无损、有损**都支持
  * WebP提供了**性能出色的压缩水平**【比PNG、JPEG都好用】
  * SVG比光栅图要**小很**多，启用 **gzip 压缩**来达到更好的优化效果

**是否支持透明**：**JPEG不透明**；PNG、GIF、WebP、SVG支持透明（PNG具有**多层级透明度**）

**是否支持动画**：JPEG、PNG不支持动画；其余GIF、SVG、WebP都支持动画

**适用场景**

* **JPEG** 色彩丰富，适用于展示摄影作品；适用于**截图场景，压缩率高。**
* **PNG** 适用于有**最高分辨率需求**的场景，无损压缩图片大

* **GIF** 适合简单色彩的图片、或是用于展示循环**动画**
* **SVG**：就超好用！
  * 可把 SVG 代码放到 HTML 中以**减少请求量**，用来展示一些**小的图片logo、地图、图标**等
  * **可塑性高**：可**用 CSS 来 DIY 任何 SVG**；**用 JavaScript 或者 CSS** 将其变成**动画**
  * **缺陷**：避免上使用非常复杂的SVG图片，因为这会导致文件的**体积变大很多**
* **WebP**：谷歌爸爸的亲儿子！超好用！**似乎有兼容问题**
  * 比 JPEG、PNG 都好用，压缩很好！

> 无论从服务器向客户端传送数据时使用哪一种图片格式，在浏览器对图像进行解码时，每个像素始终占用 4 个字节的内存。



## 如何选择图片格式

* 需要**动画**？如果需要，**GIF** 是唯一的**通用**选择。【色彩少】

* 需要使用**最高分辨率**保留精细的细节？**PNG**。【无损压缩质量高，图片大】

- 需要使用包含由**几何形状**组成的图像？ **SVG**！

- 需要**优化照片、屏幕截图**或类似的图像？ **JPEG**。【压缩率高】



## 图片优化

- **首选矢量格式：**矢量图像与分辨率和缩放无关，这使其成为**多设备和高分辨率**情况的**完美选择**【Retina屏】
- **压缩 SVG ：**大多绘图应用生成的 XML 标记**有冗余**数据；对 SVG 采用 **GZIP 压缩**可极大提高性能。
- **挑选最佳光栅图像格式：**确定您的**功能**要求并选择适合每个特定资产的格式。
- **通过试验为光栅格式找到最佳质量设置：**在图片质量与图片体积寻找平衡
- **移除多余的图像元数据：**许多光栅图像都包含**多余的元数据**：地理信息、相机信息等，使用工具删除
- **提供缩放的图像：**为不同分辨率下保存多个版本的光栅图像，可以用小图就不要请求大图。





- 









# webpack相关

## Webpack简介

webpack是一个**JavaScript 应用程序的静态模块打包器**。

当 webpack 处理应用程序时，会把整个项目引用的**静态资源**，比如 js、 css、less图片资源都**当做模块加载**（包括按需加载），处理其中的**依赖关系**，**递归构建**一个**依赖关系图**，然后将这些模块打包成**一个或多个 bundle。**

> **从 wepack V4.0.0** 开始， webpack 是**开箱即用**的，**在不引入任何配置文件的情况下就可以使用**。

* loader：模块转换器。
  * 将ES6以及更高版本的**Javascript**转换为支持较广泛的**ES5**，便于在更多浏览器中运行
  * 将less、sass 编译转化为css，借助 style-loader 来处理css文件，插入样式
  * 自动补齐CSS3浏览器兼容性前缀
  * 打包处理图片、字体等文件，url | file ，图片压缩
  * 国际化 i18n - loader
* Plugin：插件，**监听webpack构建项目过程中的事件**，插入**特定逻辑**来拓展webpack功能。
  * 指定html模板，创建index.html文件，会自动插入bundle.js
  * 去除无用代码，代码压缩
  * 抽离CSS，将CSS文件单独打包，支持按需加载；压缩CSS
  * 添加版本信息
* 本地服务器 **webpack-dev-server** 在浏览器中实时查看效果
* 使用 import() 语法可支持**按需加载**：用到时再加载
* 为**不同环境**（开发、生产环境）定义不同的配置文件，通过webpack.merge合并，实现**按需使用配置**
* 可以解决**跨域问题**
* **前端模拟数据**



## Webpack构建流程

- **初始化**：启动构建，**读取与合并配置参数**，加载 Plugin，实例化 Compiler
- **编译**：**从 Entry 出发**，针对每个 Module **串行**调用对应的 **Loader** 去翻译文件的内容，再找到该 Module 依赖的 Module，**递归地进行编译处理（得到模块转化后的内容及递归关系）**
- **输出**：将编译后的 Module **根据依赖关系组合成 Chunk**，将 Chunk 转换成文件，加到输出列表中，最终输出到文件系统中

> Webpack 会在特定的时间点**广播出特定的事件**，**插件Plugin在监听**到感兴趣的事件后会执行特定的逻辑



## bundle，chunk，module是什么?

* module是**开发过程**中的单个模块
* chunk是指webpack在**根据模块的依赖关系**，**代码分割、打包**出来的代码块
* bundle是由webpack**处理chunk后最终生成的文件**（浏览器可以直接运行）

> 简单说，**module** 就是我们写的代码（没有被编译之前），webpack根据依赖关系生成代码块**chunk**（处理进行时），webpack 处理 chunk 后，最终打包生成**bundle**。





## webpack和grunt/gulp有什么不同？

**webpack是一个静态模块化打包工具**，在这个过程中也会充当**编译器**

* 当处理应用程序时，webpack会把整个项目引用的**静态资源**，比如 js、 css、less图片资源都**当做模块加载**，处理其中的**依赖关系**，**递归构建**一个**依赖关系图**，然后**将这些模块用loader进行适当的转换**之后打包成**一个或多个 bundle。**
* webpack强调**模块化**的概念(AMD，ESM，CommonJs)

**Gulp/Grunt**是一种**优化前端开发流程的工具**。

* Gulp/Grunt中，由**开发者定义**对某些文件的**操作任务流**，类似编译，组合，压缩等任务，之后工具可以自动替你完成这些任务，完成项目构建。

* Gulp/Grunt更像是一个**构建器**。

> **Webpack**的优点使得Webpack在很多场景下**可以替代Gulp/Grunt类的工具**。

　

## Loader、Plugin

### 模块转换器 loader

**Loaders**：**模块转换器**。本质就是一个函数，用于把**模块原内容**按照需求**转换成新内容**，不同的loader能对**不同类型文件**用不同的方案进行打包，**告诉webpack如何转化处理**某一类型的文件，并且引入到**打包**出的文件中

**使用方法：** 

* npm安装loader
* 在 webpack.config.js 的 **module.rules** 中配置**模块的解析规则**，类型为数组。
* rules数组中每一项都是一个对象，包含 test、loader/use、options 等属性（也可以指定include | exclude）



**常见 loader：**

--------------------------------处理JavaScript------------------------------------

* **babel-loader：**可用于将ES6以及更高版本的Javascript转换为支持较广泛的ES5，便于在更多浏览器中运行。
* ts-loader：将 TypeScript 转换成 JavaScript
* awesome-typescript-loader：将 TypeScript 转换成 JavaScript，性能优于 ts-loader

--------------------------处理CSS、less、Sass等-----------------------------

* **css-loader：**加载 CSS，支持模块化、压缩、文件导入等特性
* **style-loader：**动态创建 style 标签，把 CSS 代码注入到 JavaScript 中
* **postcss-loader**：配合 autoprefixer 插件**自动补齐** CSS3 浏览器兼容性前缀（可指定兼容哪些浏览器）
* **less-loader**：负责处理编译 `.less` 文件,将其转为 `css`
* **sass-loader**：负责处理编译 `.sass` 文件,将其转为 `css`

--------------------------处理图片、字体等文件-----------------------------

* **url-loader**：将所有的**小于限制数值**的资源转为base64格式（limit: 10240   10k）
* **file-loader：**把文件打包、输出到一个文件夹中，生成一个**以哈希值命名**的文件，通过**相对 URL** 去引用
* **image-loader**：**加载**并且**压缩图片**文件

------------------------------------处理其它文件---------------------------------------

* **json-loader**：加载 JSON 文件
* **vue-loader**：加载 Vue.js 单文件组件

-----------------------------------代码检查等------------------------------------

* **eslint-loader**：通过 ESLint 检查 JavaScript 代码
* **tslint-loader**：通过 TSLint检查 TypeScript 代码

--------------------------------------其它----------------------------------------

* **i18n-loader: 国际化**

* coverjs-loader：计算测试的覆盖率

* handlebars-loader：将 Handlebars 模版编译成函数并返回

* html-withimg-loader：处理html文件中的本地图片【如果在index.html中使用本地图片会有问题】
* source-map-loader：加载额外的 **Source Map 文件**，以方便**断点调试**
* svg-inline-loader：将压缩后的 SVG 内容注入代码中

---

> **loader配置相关**
>
> 在 webpack.config.js 中配置 loader，指定**转换规则rules：在什么文件上（后缀）使用哪些loader进行转换**
>
> * test 字段是**匹配规则**，针对符合规则的文件进行处理
>
> * use 字段表明 **使用了什么 loader**，可以是 字符串、数组（loader 的执行顺序是**从右向左执行**的）
>
>   * ```
>     less-loader` ---> `postcss-loader` ---> `css-loader` ---> `style-loader
>     ```
>
> * exclude |  include





### 插件 plugins

**Plugin：插件**，用于**扩展 Webpack 的功能**。Plugin 基于事件流框架 Tapable，在 Webpack **运行的生命周期**中会**广播**出许多事件，**Plugin 可以监听**这些事件，在合适的时机**注入扩展逻辑**来改变构建结果或做你想要做的事情扩展插件，在webpack构建流程中的特定时机**注入扩展逻辑**来改变构建结果或做你想要做的事情

**常用插件：**

* **html-webpack-plugin**：新建 public/index.html ，不需要打包，用于在浏览器中显示，自动插入bundle.js
  * 依赖于html-loader，指定html模板，打包后的文件名等
  * 除此之外可以新增一个config，通过true/false选择在index.html中引入什么功能/内容（可定制性）。
* **web-webpack-plugin**：可方便地为单页应用输出 HTML

* **uglifyjs-webpack-plugin**：压缩Javascript代码，同时通过Tree-shaking来**去除一些无用代码**
* terser-webpack-plugin: 支持压缩 ES6 (Webpack4)
* mini-css-extract-plugin：**抽离CSS**，将CSS文件单独打包，**支持按需加载**
  * 【可能是因为打包成一个JS文件太大，影响加载速度，也有可能是为了缓存，只有JS文件变动了】
* optimize-css-assets-webpack-plugin：将**抽离**出来的css文件进行**压缩**

* speed-measure-webpack-plugin: 可以看到每个 **Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)**
* webpack-bundle-analyzer: 可视化 Webpack **输出文件的体积** (业务组件、依赖第三方模块)

* **ignore-plugin**：在模块化的过程中忽略部分文件
* **DefinePlugin**：定义环境变量（标识符）

* **HotModuleReplacementPlugin**：热更新插件：修改代码，不会造成整个页面的刷新

* clean-webpack-plugin：打包前自动清空dist文件【每次文件修改，打包，会导致dist文件越来越多



> **plugins配置相关**（在 webpack.config.js 中配置）
>
> npm安装插件后，在 webpack.config.js 中通过require引入，new 创建插件实例并将参数传入构造函数



### Loader、Plugin是什么?

**Loaders**：**模块转换器**。本质就是一个函数，用于把**模块原内容**按照需求**转换成新内容**，不同的loader能对**不同类型文件**用不同的方案进行打包，**告诉webpack如何转化处理**某一类型的文件，并且引入到**打包**出的文件中

**Plugin：插件**，用于**扩展 Webpack 的功能**。Plugin 基于事件流框架 Tapable，在 Webpack **运行的生命周期**中会**广播**出许多事件，**Plugin 可以监听**这些事件，在合适的时机**注入扩展逻辑**来改变构建结果或做你想要做的事情



### Loader、Plugin的区别

* **作用不同**：**Loaders是模块转换器**；**Plugin插件**，用于**扩展 Webpack 的功能**。
* **配置方法**：npm安装后在webpack.config.js中配置
  * **Loader** 在 module.rules 中配置**模块的解析规则**，类型为数组。rules数组中每一项都是一个对象，包含 test、loader/use、options 等属性（也可以指定include | exclude）
  * **Plugins** 在 plugins 中配置，类型为数组，**每一项是一个 Plugin 的实例**，**参数都通过构造函数传入**



### file-loader & url-loader

**共同点：**在Webpack中可以用 file-loader 或 url-loader 来**对图片进行打包**。

**不同点**

* **打包原理不同**
  * file-loader实际上只**将图片进行了文件目录的转移**，打包后生成一个新的**以哈希值命名**的图片文件。
  * url-loader却可以**将限制范围内的图片文件以base64位的形式进行处理**
* **适用情景不同**
  * 当**图片很小**时适合用**url-loade**r，将资源转化为base64可以尽可能的**减少网络请求次数（只请求main.js文件即可）**、提前加载图片（网络不好时候提前显示图片）
  * 当**图片比较大**时适合用**file-loader**，因为能让main.js**更快地加载**出来。

>  base64 数据较大，如果太多的资源是 base64，会导致加载变慢，因此设置 limit 值时，需要二者兼顾。





## 如何自动生成webpack配置？

脚手架工具 webpack-cli / **vue-cli** /etc ...





## webpack-dev-server和HTTP服务器有什么区别?

webpack-dev-server是一个小型的Node.js Express服务器，**使用内存来存储webpack开发环境下的打包文件**，并且可以使用**模块热更新**，他比传统的http服务对开发**更加简单高效**。





## 什么是模块热更新？

**模块热更新：不需要页面重载刷新，修改代码就可以直观地在页面上看到变化**.

**作用：**提高开发效率

如何开启模块热更新：

* 使用 HotModuleReplacementPlugin 插件
* 打开 webpack-dev-server 的热更新开关

> 微信小程序的开发工具，没有提供类似 Webpack 热更新的机制，所以在本地开发时，每次**修改了代码，预览页面都会刷新**，于是之前的路由跳转状态、表单中填入的数据，都没了。





## 什么是Tree-shaking？CSS可以Tree-shaking吗

**Tree-shaking**是指在打包时**去除**那些**引入了**，**但在代码中没有用到**的那些死代码（Javascript中的未引用代码）

* 在webpack中**Tree-shaking**是通过**uglifySPlugin**来Tree-shaking，同时也会对Javascript代码进行压缩
* CSS可以通过使用**Purify-CSS**来剔除一些没有用到的样式（可能会**破坏通用模块css的缓存**）
  * 解决：不精简通用模块css，只精简具体业务相关的css。



## webpack效率提升

* **配置loader时指定 include | exclude**，表明对哪些文件进行转换编译（或排除），**有效提升编译效率**

  ```
  经常会用 exclude: /node_modules/ 来排除 node_modules 目录（npm包）
  ```

* **配置文件的分割、合并**：根据开发环境、生产环境分别创建配置文件，**提取公共配置**，减少重复配置代码；借助**webpack-merge插件**来合并配置

* **speed-measure-webpack-plugin**：简称 SMP，**分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时**，有助于找到构建过程中的**性能瓶颈**。

* **模块热更新**：HotModuleReplacementPlugin插件，更新代码时局部更新，不必进行页面重载



## 如何对bundle体积进行监控和分析？

* **VSCode** 插件 Import Cost 可实时监测引入模块的大
* **Webpack插件 webpack-bundle-analyzer** 生成 bundle 的模块组成图，显示所占体积。



## Webpack代码分割

代码分割的本质：用可接受的**服务器性能压力**增加来**换取更好的用户体验。**

* **（不打包）源代码直接上线**：过程可控，但是http**请求多**，**服务器性能开销大**。

* **（打包）打包成唯一脚本**：减少HTTP请求，**服务器压力小**；但请求资源过大，可能出现白屏（页面空白期长），用户体验不好。

---

另一方面**代码分割**也可以**更好地利用浏览器缓存**

**问题**：在开发中一般会用到第三方库，一般情况下不会去修改**第三方库**的源码；但是**业务逻辑代码**是要根据需求进行修改的。如果将它们**都打包到一起**，那么一旦改了业务逻辑代码，用户重新访问页面的时候，**就要连同第三方库的代码及业务代码全部重新下载一遍**，但其实第三方库那一部分代码是没必要重新下载的。

**解决**：**使用代码分割**，那么只要**将不经常改动的代码打包到一起**，**经常改动的代码打包到一起**，利用浏览器的缓存**将这些不经常改动的代码缓存起**来，就可以让用户在每次访问页面的时候**减少请求的次数及请求资源的大小**。



## devtool

`devtool` 中的一些设置，比如 **source-map**，最终会打包出一个map文件，可以帮助我们**将编译后的代码映射回原始源代码**。不同的值会明显影响到构建和重新构建的速度



## resolve 配置

**配置 webpack 如何寻找模块所对应的文件**。

`webpack` 内置 `JavaScript` 模块化语法解析功能，**默认会采用模块化标准里约定好的规则**去寻找，但你可以根据自己的需要修改默认的规则。

* **modules**：配置 `webpack` **默认情况下去哪些目录寻找第三方模块**，一般是node_modules

* **alias**：**配置别名**，把原导入路径映射成一个新的导入路径

* **extensions**：配置后可以**缺省文件后缀**，在导入语句没带文件后缀时，会自动带上extensions 中配置的后缀后，去尝试访问文件是否存在



## Base64相关

### 特点/优点

* Base64编码后的字符串在网关之间传递**不会产生Unicode字符串不能识别或者丢失**的现象
* Base64对图片进行编码，就可以用XML或者在数据库中直接**以文本的形式来存储图片**，**减少请求次数**



### 应用场景

* 在**传统的前后端鉴权方案**中有一种 **Http Basic身份认证**，通过验证用户名、密码来鉴权。
  * 如果用户没有认证，那么在发送请求时服务器端会返回**401状态码**，客户端检查请求头中的字段后弹出登录窗口，让用户输入用户名、密码，之后用户名和密码会**以Base64编码的方式**传递到服务器端。
* **Webpack中的url-loader**会对limit限制内的资源用Base64进行编码、打包，可以将图片转化为Base64字符串，主要作用在于**可以减少网络请求次数**



### 使用base64做图片转换的缺点

* 若**转化的图片太大**，导致**生成的字符串数据太大**，**加载过慢**，10240
* 使用base64转化的**资源将不会拥有缓存**









# Babel

## Babel是什么？

Babel 是一个 JavaScript 编译器，可用于将ES6的代码转换为支持较广泛的ES5代码，便于在更多浏览器中运行。

当然不是只能用于将ES6编译成ES5，只要有，或者是编写对应的插件就可以将代码转化为其他语言。

> 此外Babel 还拥有众多模块，可用于不同形式的**静态分析**，**在不需要执行代码的前提下对代码进行分析**，可以用于语法检查，编译，代码高亮，代码转换，优化，压缩等等场景。



## Babel编译过程（代码转换）

Babel的编译过程大致可以分为三个阶段：

* **解析**：使**用babylon解析器**，它会根据输入的**javascript代码字符串**根据**ESTree规范（静态语法描述）**生成 AST，具体分为**词法分析**和**语法分析**两个阶段
  * **词法分析**：把字符串形式的代码转换为 **令牌tokens**流，可以把令牌看作是一个扁平的**语法片段数组**。
  * **语法分析**：**递归**遍历，使用token中的信息，分析token之间的关系，把这些token**流转换成一个 AST 的表述结构**
* **变换**：接收 AST 并对其进行**遍历**，在此过程中**根据一定的规则转换**对节点进行添加、更新及移除等操作。
  * 这也是**插件**将要介入工作的部分，在webpack中配置babel-loader有一个presets，就是插件集合。
* **生成**：用 **babel-generator** 来**深度优先遍历**整个 AST，将AST转换成**字符串形式的代码**，同时创建源码映射

### 抽象语法树

抽象语法树是**源代码语法结构**的一种抽象表示。以树状的形式表现编程语言的语法结构，其中树上的每个节点都表示源代码中的一种结构。

AST是源代码的一种映射，某种规则中二者**可以相互转化**，计算机中**语言引擎**根据AST就能知道代码的作用是什么

ASR中每一层都有相同的结构（每一层结构也被叫做 **节点（Node）**）

```js
{
  type: "FunctionDeclaration"，
  id: {...}，
  params: [...]，
  body: {...}
}
```

```js
{
  type: "Identifier"，
  name: ...
}
```

### Webpack中使用babel

* **安装  babel-loader** （npm安装）
* **安装 babel 其他相关依赖**，比如@babel/core、preset、plugins
* **配置 loader**，指明转换规则：在哪些文件上使用babel-loader进行转换
* **配置 babel**：可以在 **.babelrc** 中编写 babel 的配置，也可以在 **webpack.config.js** 中进行配置
  * 配置 preset、plugins

```
npm安装 => 配置loader => 选择presets【插件】
```







# 前端缓存相关

## 前端缓存

浏览器中的缓存，根据**缓存位置**划分一共有四种，按优先级从高到低排列分别是

- Service Worker
- Memory Cache
- Disk Cache 【我们常说的HTTP缓存：强缓存、协商缓存也属于这个范畴】
- Push Cache

> 按优先级排序，从上往下依次检查是否命中，如果但都没有命中则会重新发起网络请求



### Service Workers

* Service Worker 借鉴了 **Web Worker** 的 思路，即让 Javascript 运行在主线程之外，是运行在浏览器背后的**独立线程**（额外的脚本），能帮助我们完成很多有用的功能，比如 **离线缓存、消息推送和网络代理** 等。

* 由于它脱离了浏览器的窗体，因此**无法直接访问 DOM** 。

---

其中的离线缓存就是 **Service Worker Cache**。

相比于其它缓存方式、缓存策略， **Service Worker Cache**  提供了另外一种**更加灵活、更加直接**的操作方式：可以自行指定缓存哪些文件、如何匹配缓存、如何读取缓存等。

如果 Service Worker **没能命中缓存**，一般情况会使用 **`fetch()` 方法继续获取资源**。这时候，浏览器就去 **memory cache 或者 disk cache** 进行下一次找缓存的工作了。

**特点：**

* 存放位置： Chrome 的 F12 中，**Application -> Cache Storage**
* 时效：**永久性**的，除非手动调用API删除或容量超过限制被浏览器删除



### Memory Cache

memory cache的特点是**读取快，短期存储**，保证了**一个页面中如果有两个相同的请求**，实际上也**只会请求一次**

**常规**情况下，**浏览器的 TAB 关闭**，也就是**渲染进程结束**，就会导致该次浏览的 **memory cache 失效**

**极端**情况下（单页面的缓存占用了很多内存），那可能**在 TAB 没关闭之前，前面的缓存就已经失效了。**

> **几乎所有的网络请求资源**都会被浏览器**自动加入到 memory cache** 中
>
> 如果实在不想要缓存，就设置**no-store**



### Disk Cache / HTTP Cache

disk cache的特点**读取稍慢，持久存储**

* **disk cache允许相同的资源在跨会话，甚至跨站点的情况下使用**，例如两个站点都使用了同一张图片。
* 当disk cache容量过多时**浏览器也会用特点的算法自动清理**

> 浏览器如何决定将资源放进内存还是硬盘呢？主要策略如下：
>
> - 大型的 JS、CSS文件会直接被放到disk cache中
> - 看内存的使用/空闲情况，如果内存使用率很低就优先将缓存放入内存，反之则放入磁盘。



### Push Cache（推送缓存）

* Push Cache是 HTTP/2 中的内容，是一种存在于**会话阶段**的缓存，当 session 终止时，缓存也随之释放。

- 不同的页面只要**共享**了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。



## 三级缓存原理

1. 先去**内存**看，如果有，直接加载
2. 如果内存没有，择取**硬盘获取**，如果有直接加载
3. 如果硬盘也没有，那么就**进行网络请求**，并将加载到的资源缓存到硬盘和内存

---

> 现象：
>
> * 访问-> 200 -> 退出浏览器
>
> * 再进来-> 200(from disk cache) -> 刷新 -> 200(from memory cache)







# 前端本地存储相关

本地存储主要用在**前端有大容量存储需求的页面**上，例如，在线编辑或者网页邮箱。

### **Cookie** 

* cookie本身并不是用来做本地存储的，是设计用来弥补 **HTTP无状态** 的缺陷，也就是**状态存储**，所以算是一种滥用吧，被滥用为做本地存储。
* Cookie的**具体表现**为一个存储在浏览器本地的一个小文本文件，内容是**键值对形式的字符串**



### WebStorage：sessionStorage 

* 存储容量大，一般可以有**5兆**；通过**Windows.sessionStorage 属性**使用
* **sessionStorage** 一的特点就是，它是**会话级别**的，在会话关闭之后就会消失，可以用它来**存储本次浏览记录**，也就是一些关闭页面后不再需要的记录。
  * 可用来**维护表单信息**，将表单信息存储在里面，保证页面即使刷新也不会让之前填写的表单信息丢失。



### WebStorage：localStorage

* 存储容量大，一般可以有**5兆**；通过**Windows.localStorage 属性**使用

* **localStorage** 具有**较大容量和持久的特性**，需要手动删除
  * 可以利用localStorage存储一些**内容稳定的资源**，比如官网的logo，存储Base64格式的图片资源

* local Storage 遵循**同源策略**，不可跨域



### indexDB

indexDB 是浏览器提供的**本地数据库**，它**可以被网页脚本创建和操作**，理论上没有容量限制，为大型数据的存储提供了接口，便于使用，减少向服务器端请求资源。

indexDB是一种**非关系型数据库**，不支持SQL查询语句，拥有数据库的特性，比如支持事务、存储二进制数据。

1. 内部采用**键值对**的方式来存储
2. 异步操作。数据库的读写属于 I/O 操作， **浏览器中对异步 I/O 提供了支持**。
3. **受同源策略限制**，即无法访问跨域的数据库。



## cookie作为本地存储选择的缺点

* **容量缺陷**：cookie**存储量小，只有4KB**，域名下的cookie数也是有限的
* **性能缺陷**：Cookie 紧跟域名，发出对应请求时都会携带上完整的 Cookie，随着请求数的增多，会造成巨大的性能浪费的，携带了很多不必要的内容。
* **可操作性缺陷**：**需要自己封装**获取、设置、删除cookie的方法

* **安全缺陷**
  * 在 Cookie 的有效期会**自动被发送给服务器**，这是相当危险的。
  * Cookie **以纯文本的形式**在**浏览器和服务器中**传递，很**容易被非法用户截获**。
  * 在**HttpOnly**为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。
  * 超出域名下的cookie数限制时可能会**被自动清除**



## localStorage和sessionStorage的异同点

#### 共同点

* 都是WebStorage的实现之一，用来存储**浏览器端**临时信息的对象，**不同浏览器之间无法共享**
* **只能存储字符串类型的对象**（规范中有其它原生对象，但无浏览器实现）
* **同源**
* 不会自动把数据发给服务器，仅在本地保存（区别于cookie）
* 支持事件通知机制，可以将数据更新的通知发送给监听者，提供了相关的API接口
* 存储容量5MB或5MB以上

#### 不同点

* **数据有效期**

  * localStorage是一种持久化存储方式，**长期存在**，**除非使用Javascript删除/清除浏览器缓存**
  * sessionStorage是一种会话级别的存储方式，生命周期为当前窗口，当**会话结束（浏览器窗口关闭或标签页被永久关闭）**时就会被清除

* **作用域**

  * **同一浏览器**的**相同域名和端口的不同页面间**可以共享相同的 localStorage
  * **不同页面间无法共享sessionStorage**的信息
    * **仅指顶级窗口**，如果一个标签页包含**多个iframe标签**且他们属**于同源**页面，那么他们之间是**可以共享**sessionStorage的



## cookie、localStorage和sessionStorage区别 

* **存储数据类型**
  * cookie是一个**小型文本文件**
  * localStorage和sessionStorage只能存储**字符串数据**，可以通过**JSON对象提供的parse和stringify**将其他数据类型转化成字符串再进行存储
* **生命周期**
  * cookie：**可设置失效时间，没有设置的话，默认是关闭浏览器后失效**
  * localStorage：除非被手动清除，否则将会永久保存。
  * sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。
* **存放数据大小**
  * cookie：4KB左右
  * localStorage和sessionStorage：可以保存**5MB**的信息。
* **是否参与服务器通信**
  * cookie：每次都携带在HTTP头中，会存在一些**性能问题和安全问题**
  * localStorage和sessionStorage：**仅在客户端（即浏览器）中保存**，不参与和服务器的通信
* **易用性**
  * cookie：需要程序员**自己封装**，原生的Cookie接口不友好
  * localStorage和sessionStorage：**原生接口使用方便**，setItem 和 getItem，也可再次封装来对Object和Array有更好的支持；支持**时间通知机制**
* **作用域**
  * **同一浏览器**的**相同域名和端口的不同页面间**可以共享相同的 **localStorage、cookie**
  * **不同页面间无法共享sessionStorage**的信息



## local Storage如何设置过期时间

> 思路：重写localStorage

```javascript
export default {
  //默认存储时长
  age: 30 * 24 * 60 * 60,
  
  //设置存储时长
  setAge: function (newAge) {
    this.age = newAge
    return this
  }，

  //是否过期
  isExpire: function (key) {
    let value = JSON.parse(localStorage.getItem(key))
    let now = new Date().getTime()
    if (!value || value._deadline < now) {
      localStorage.removeItem(key)
      return true
    }
    return false
  }，

  //重写setItem
  set: function (key, value) {
    if(!this.isExpire(key)) localStorage.removeItem(key)
    let obj = {}
    let now = new Date().getTime()
    obj._time = now
    obj._deadline = now + this.age
    obj._value = value
    localStorage.setItem(key, JSON.stringify(obj))
  }，

  //重写get
  get: function (key) {
    if (!this.isExpire(key)) {
      return JSON.parse(localStorage.getItem(key))._value
    }
    return null
  }，

  //重写removeItem
  remove: function (key) {
    localStorage.removeItem(key)
  }，

  clear: function () {
    localStorage.clear()
  }
}
```

```javascript
import localStorage from './localStorage'

localStorage.setAge(2000).set('message', '我还没过期呢！')
console.log(localStorage.get('message'));

setTimeout(() => {
  console.log(localStorage.get('message'))
}, 3000)
```



# 前后端鉴权相关

鉴权，指的就是**验证用户是否拥有访问系统的权利**。



## 常见的前后端鉴权方式

* **HTTP Basic Authentication** (HTTP基本认证)【古老】
* **session-cookie**
* **Token 验证**（包括JWT，SSO）

* **OAuth**（开放授权）



## HTTP Basic Authentication

**核心概念：**通过**核对用户名、密码**的方式，来实现用户身份的验证（**浏览器**遵守http协议实现的**基本授权方式**）

**特点：**简单、古老、有安全缺陷

#### 认证过程

* **客户端向服务器发送请求**

* **质询（响应首部www-Authenticate）**：如果客户端尚未被验证，服务器返回**401状态码（未授权）**，不返回资源，**希望用户提供用户名和密码**；响应头携带**www-Authenticate**，描述当前想要请求资源所在区域。
  * 客户端收到**401状态码**，并**检测到响应头部www-Authenticate**会自动弹出**用户名和密码输入界面**

* **授权（请求首部Authentication）**： 用户输入用户名和密码后，客户端重新发送请求，并附加**请求首部Authentication**，用来说明认证算法，用户名和密码，用户名和密码用冒号分隔，并将用户名及密码**默认**以**base64编码**。
* 服务器收到上述请求信息后，将Authorization字段后的**用户信息取出、解码**，将解密后的用户名及密码**与用户数据库进行比较验证**，如用户名及密码正确，服务器则根据请求，**将所请求资源发送给客户端**

> 服务器会把受保护的文档组织成一个**安全域**，每个安全域都可以有**不同的授权用户集**。
>
> 所以服务器会有多个不同的安全域，每个安全域都有自己的密码。
>
> 服务器在www-Authenticate响应首部**对保护区域进行描述**，同样指定响应的认证算法。

#### 优点

基本上所有流行的网页浏览器都支持Basic基本认证

#### 弊端

* 默认用**base64**对用户名和密码进行编码，相当于它还是一个**明文密码**，可能导致密码泄露等问题。
  * 在**传输层未加密**的情况下，用户**明文密码可被中间人截获**。
  * 明文密码一旦泄露，如果用户**其他站点也用了同样的明文密码**，那么用户其他站点的**安全防线也告破**。
* 服务器端在用户不关闭浏览器的情况下，并**没有一种有效的方法来让用户注销**。
  * 保存认证信息直到：关闭浏览器 / 关闭保存认证信息的标签页 / 清除历史记录

**根据弊端给出建议：**

1. **传输层**未加密的情况下，不要使用Basic认证。
2. 如果使用Basic认证，**登录密码由服务端生成**。
3. 如果可能，**不要使用Basic认证**。



## session-cookie

**原理：**利用**服务器端的session**和**浏览器端的cookie**来实现前后端的认证。【HTTP无状态】

#### 认证过程

* 客户端**首次访问**，服务器**创建并保存对应Session**，给这个**session**生成一个**唯一的标识字符串sessionID**，之后会将sessionID放入响**应头字段set-Cookie**中。
  * 创建sessionid的方法：**随机数+时间+jvmid**
  * **签名**。可以对sessionID进行加密处理，服务端会根据这个secret密钥进行解密。**（非必需步骤）**
* **生成Cookie**：浏览器中收到请求响应的时候会**解析响应头**，然后将sessionID**保存在本地cookie**中
* **发送Cookie**：浏览器在**下一次**http请求的请求头中会**自动带上该域名下的cookie信息**。
* **验证sessionID**：服务器在接受客户端请求时会去解析请求头cookie中的sessionID，然后根据这个sessionID**去找服务器端保存的该客户端的session**，然后判断该请求是否合法。

#### 弊端

- **服务器消耗大**：用户每做一次**应用认证**，应用就会在服务端做一次记录，**占存储空间**
- **易受到CSRF攻击**：借助Cookie，而Cookie容易被截获，有CSRF攻击的安全风险
- session-cookie 认证方式**局限于浏览器**，因为cookie是浏览器端的机制，不能用于原生APP



## Token校验（JWT、SSO）

token是用户身份的验证方式，通常称之为**Token令牌**。

当用户第一次登录后，服务器随机生成一个token并将此token返回给客户端，那么在token失效之前，客户端只需带上这个token前来请求数据即可，**无需再次带上用户名和密码。**



#### Token的组成

**最简单的token组成**：uid（用户唯一的身份标识）、当前的时间戳、由hash算法加密生成的签名字符串

* hash算法加密：防止恶意第三方拼接token请求服务器



#### 认证过程【解密+用户信息查询】

* **客户端使用用户名和密码请求登录**：    【使用**用户名跟密码**登录】

- **服务器端**验证，**签发Token并返回**给客户端
- **客户端存储Token**：【放在 Cookie 里或 Local Storage 里】
- **客户端**每次向服务端请求资源的时候需要**带着服务端签发的 Token**
- **服务端**收到请求就去**验证请求里面带着的 Token**【验证成功：200+资源；验证失败：401，表示鉴权失败】

> 可以把Token想象成一个**安全通行证**。我们**在一个安全的前台验证**（通过你的用户名和密码**）身份**，验证成功就拿到了 **通行证**。之后我们走进大楼的时候，如果要执行一些权限限制行为时，保安拦住我们，要求验证通行证，我们就只需要拿出通行证，不需要重新返回安全前台重新验证。



#### Token的优点

- token 完全**由应用管理**，不局限于cookie，**可支持多种客户端**，也可避开同源限制
- Token 可以**避免 CSRF 攻击**（不需要Cookie了，不怕被挟持）
- Token **可以是无状态的，可以在多个服务间共享**
- 相较于session而言**可扩展性更强**，解决方案多（常用JWT）



#### Token的缺点

- **更占带宽**：正常情况下**token要比 session_id更大**，需要消耗更多流量，挤占更多带宽。
- **性能问题**：**加密解密消耗性能，**相比于session-cookie来说就是一个**"时间换空间"的方案**.
- **服务器无状态（优缺点）**：一旦签发Token不可撤销，不能再修改它的权限，过期之前都可用；如果用户重置密码了，服务器不知道哪些未到期的token是应该被废弃了的（后端控制：例如维护token黑名单）



### Token和session的区别 

* **服务器性能消耗**

  * Session需要**保存在服务器**中，**占大量存储空间**
  * Token**加密解密有性能消耗**，属于一个**"时间换空间"的方案**.

* **服务器无状态**

  * session-cookie 需要**将session保存在服务器**，保存了一些用户的会话登录状态
  * **Token认证中服务器有无状态的特点**：token本身就保存用户的登录状态；服务器只需要对token进行加密解密、进行用户数据查询来验证用户

* **带宽**：正常情况下**token要比 session_id更大**，需要消耗更多流量，挤占更多带宽。

* **时效性**：

  * session-cookie的sessionid是在初始登录时生成的，之后不变，在一定程度上安全就会降低
  * token在一段时间内可以动态改变的【动态token】

* **Token不需要借助Cookie**

  * **局限性：客户端类型**

    * session-cookie 认证方式**局限于浏览器**，因为cookie是浏览器端的机制，不能用于原生APP

      > 只有浏览器才会去解析请求响应头里面的cookie，请求携带Cookie

    * token 不局限于cookie，**可支持多种客户端**，且不受同源策略影响

  * **CSRF攻击**：token不使用cookie，可以避免CSRF攻击

* **可扩展性**：token验证比较灵活，一是**token的解决方案**多，常用的是JWT；二来我们可以**基于token验证机制**，专门做一个鉴权服务，用它**向多个服务的请求进行统一鉴权**。







### Token过期与Refresh Token

**Token过期：**token是访问特定资源的凭证，**出于安全考虑token有过期时间**，一般不会超过一个小时。

**Refresh Token ：** 加密字符串，并且和token是相关联的，**用于获取新的token**。

* **过期时间**：refresh token的作用仅仅是获取新的token，并不是用来获取资源，因此其**作用和安全性要求都较低**，过期时间长一些，可以设置以天为最小单位。如果**refresh token过期**了，还是需要**重新登录验证**的.



#### 为什么要有refresh token?

* 如果token过期了，就要重新获取，继续**重复第一次获取token的过程（比如登录，扫描授权等）**，那么可能每一小时就必须获取一次，这样做是**非常不好的用户体验**。**通过refresh token去重新获取新的 token. 会好一点**





### JWT（JSON Web Token）【跨域认证解决方案】

http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html

#### JWT原理

服务器认证以后，**生成一个 JSON 对象**发回给用户，之后用户与服务器通信的时候。服务器完全只**靠这个JSON对象认定用户身份**。为了**防止用户篡改数据**，服务器在生成这个对象的时候，也会加上**签名**。

【实质上是字符串，由 JSON对象通过**Base64编码**转化而成】

**特点**： 服务器**不需要保存任何 session 数据**了，也就是说，服务器变成**无状态**了，从而比较**容易实现扩展**。

> **认证过程**：
>
> * 首次登录时，服务器判断用户账号密码正确后，根据用户id、用户名、定义好的秘钥、过期时间等信息**生成 token** ，返回给客户端；
> * 客户端拿到后端返回的 token，存储在 localStroage | Vuex 里； 
> * 客户端在每次路由跳转时，判断 localStroage 有无 token ：没有则跳转到登录页，有则请求获取用户信息，改变登录状态； 每次请求接口时，在 Axios 请求头里携带 token；
> * 后端接口判断请求头有无 token，没有/token 过期，返回401； 前端拿到响应，重定向到登录页面。

#### JWT 的数据结构

实际上 JWT 是一个很长的**字符串**，中间用点（ . ）分隔成三个部分，分别是：**Header.Payload.Signature**

- **Header（头部） ：** 一个 JSON 对象，**描述 JWT 的元数据**，eg：签名算法、token类型

- **Payload（负载）:** 一个 JSON 对象，存放实际**需要传递的数据**，**默认不加密**【尽量不要携带敏感信息】

- **Signature（签名）:** 部分是对前两部分的签名，**防止数据篡改。** 
  - 服务器指定一个**密钥**（只有服务器知道），使用 Header 里面指定的**签名算法**

#### JWT 的特点

- **默认不加密**：可以在生成原始 Token 以后，用密钥进行加密
- **有效时间短**：JWT 本身**包含了认证信息**，有效时间短可以减少盗用，必要时也需重新验证
- 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要**使用 HTTPS 协议传输**。
- JWT **不仅可以用于认证**，也可以用于**交换信息**。有效使用 JWT，可以**降低服务器查询数据库的次数**。

#### JWT的缺点

服务器**不保存 session 状态**，因此**无法在使用过程中废止某个 token**，或者**更改 token的权限**（用户改密码）

也就是说，一旦 JWT 签发了，在**到期之前就会始终有效**，除非服务器部署额外的逻辑。



#### 补充： 后端主动让JWT失效的方法（需要后端添加状态）

- **将 token 存入 DB中**，失效则删除；【校验时需在DB中检查token，违背无状态原则，不推荐】
- **维护一个 token 黑名单**，失效则加入黑名单中【黑名单体积小，使用频率低，开销小，**常用**】
- 在 JWT 中增加一个**版本号字段**，失效则改变该版本号。
- 在服务端设置加密的 key 时**，为每个用户生成唯一的 key，失效则改变该 key。**



### 单点登录 SSO

单点登录，简称 SSO：在多个应用系统中，用户**只需要登录一次就可以访问所有相互信任的应用系统**。

用户访问子系统时，检查登录状态，若未登录，则跳转至

SSO一般都**需要一个独立的认证中心**，**子系统的登录均得通过该认证中心**，本身将不参与登录操作。

当一个系统成功登录后，passport会**颁发令牌给各个子系统**，子系统可以拿着令牌会**获取各自的受保护资源**。

减少频繁认证，各个子系统在被passport**授权以后**，会建立一个**局部会话**，在一定时间内可以无需再次向passport发起认证

> 单点登录（Single Sign On）是目前比较流行的企业业务整合的解决方案之一



#### 认证流程

- 用户访问**子系统1**，**子系统1**发现用户**未登录**，**跳转至sso认证中心**，并将自己的地址作为参数

- **sso认证中心**发现用户**未登录**，将用户引导至**登录页面**，用户输入用户名、密码提交登录信息。

- **sso认证中心**校验用户信息，**创建用户与sso认证中心之间的会话**，称为**全局会话**，同时**创建授权令牌**

- sso认证中心带着令牌**跳转回最初的请求地址（系统1）**，将令牌交于**子系统1**

- 子系统1去sso认证中心**校验令牌是否有效**

- sso认证中心校验令牌，返**回有效，进入子系统1**

- 系统1使用该令牌创建与用户的会话，称为**局部会话**，返回受保护资源

  

- 用户访问系统2，系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数

- **sso认证中心发现用户已登录**，跳转回系统2的地址，并**附上令牌**

- **系统2**拿到令牌，**去sso认证中心校验令牌是否有效**

- sso认证中心校验令牌，返回有效，注册系统2

- 系统2使用该令牌创建与用户的**局部会话**，返回受保护资源



#### 局部会话 & 全局会话

**全局会话**：用户登录成功之后，**用户与sso认证中心建立的会话称为全局会话**

* 作用在于记录登录状态，派发令牌

**局部会话**：用户**与各个子系统建立的会话称为局部会话**

* 作用在于保持用户与子系统的登录关系，之后访问子系统受保护资源将不再需要通过sso认证中心

> 全局会话与局部会话有如下约束关系
>
> - 局部会话存在，全局会话一定存在
> - 全局会话存在，局部会话不一定存在
> - 全局会话销毁，局部会话必须销毁



#### 注销

sso认证中心一直**监听全局会话的状态**，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作。

- 用户向**系统1发起注销请求**
- 系统1根据用户与系统1建立的会话id**拿到令牌**，**向sso认证中心发起注销请求**
- sso认证中心校验令牌有效，**销毁全局会话**，同时取出所有用此令牌注册的系统地址
- sso认证中心**向所有注册系统发起注销请求**
- 各注册系统接收sso认证中心的注销请求，**销毁局部会话**
- sso认证中心引导用户至登录页面





## OAuth 2.0

OAuth就是**一种授权机制**。OAuth**允许用户授权第三方网站访问进入系统**，而**不需要将用户名和密码提供**给第三方网站或分享他们数据的所有内容。

为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要**显式的向用户征求授权**。

我们**常见的**提供OAuth认证服务的厂商有QQ,微信，微博等。

---

在前后端分离的情境下，我们常使用授权码方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。

**GitHub第三方登录示例**

* **在GitHub中备案第三方应用**，GitHub会给第三方应用一个专属的**客户端ID和客户端密钥**。
* 如果在第三方网站中提供一个Github登录链接，用户点击该链接后就会带着客户端ID跳转到Github，向Github请求授权码code
* 用户跳转到Github，**输入Github的用户名密码**，表示用户**同意使用Github身份登录第三方网站**。
* 此时就会**带着授权码code跳回第三方网站**【跳回的地址在创建该OAuth时已经设置好了。
* **第三方网站**收到授权码，就可以拿着**授权码、客户端ID和客户端密钥**去向Github请求**access_token令牌。**
* Github收到请求，向第三方网站颁发**access_token令牌。**。
* 第三方网站收到令牌，就可以**暂时拥有Github一些请求的权限**，比如说拿到用户信息，拿到这个用户信息之后就可以构建自己第三方网站的token，做相关的鉴权操作。









