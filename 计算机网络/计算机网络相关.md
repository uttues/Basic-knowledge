## 常见的服务端推送的通信解决方案

https://juejin.im/entry/59e08d2e6fb9a04514630e8b

**传统轮询（短轮询）**：客户端**每隔一段时间调用**接口，无论有没有数据，**接口立即返回**

* **优点**：开发简单，客户端实现即可，不需要服务端配合
* **缺点**：**无用请求多**，占用**服务端资源**；消息及时性较差
* **使用场景**：不想折腾的开发者，**消息及时性**要求没那么高，**服务器资源资源足**。

**长轮询**：客户端**每隔一段时间调用**接口，当 **服务端有数据|超时** 时返回，否则没有数据时也hang住链接

> 超时时间需要综合考虑服务器性能和及时性做出平衡，有代理的话需要考虑代理对于链接的超时机制）。

- **优点**：**消息较及时**，命中率高，**消耗服务端资源少**
- **缺点**：**服务端和客户端需要同时改造**，消息会有**部分延迟**（发生在请求交替之时）
- **使用场景**：扫码登录，微信网页端获取消息等。

**websocket**

- **优点**：**通信及时**，通信模式采用**双工**，类似于打电话
- **缺点**：服务端和客户端需要同时改造，当链接过多时，消耗服务端资源比较大。
- **实现方式**：客户端和服务端**建立长链接**，通过**在请求头中增加 upgrade：websocket 及通信密钥（Sec-WebSocket-Key）**，使双方握手成功，建立**全双工通信**，基于socket的需要**维持心跳**【101状态码】
- **使用场景**：**实时性要求很高**，银行系统，股票系统等







## URI、URN和URL的区别

**URI，uniform resource identifier，统一资源标识符，用来唯一的标识一个资源，**区分互联网上不同的资源。

- Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的
- **URL和URN是具体的资源标识方式**，URL和URN都是一种URI。（集合URI=URL+URN）

**URL，uniform resource locator，统一资源定位器**，一种具体的URI，指明了**如何locate这个资源**，即URL可以用来标识一个资源，。

- Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上

- URL结构：

  ![image-20200328115915488](D:\Uttues\Basic-knowledge\计算机网络\计算机网络相关.assets\image-20200328115915488.png)

  * **scheme** 表示**协议名**，比如`http`, `https`, `file`等等。后面必须和`://`连在一起。

  * **user:passwd**@ 表示登录主机时的**用户信息**，不过很不安全，**不推荐使用，也不常用**。

  * **host:port**表示**主机名和端口号**。

  * **path**表示请求**路径**，标记资源所在位置。

  * **query**表示**查询参数**，为`key=val`这种形式，多个键值对之间**用`&`隔开**。

  * **fragment**表示 URI 所定位的资源内的一个**锚点**，浏览器可以根据这个锚点跳转到对应的位置。

**URN，uniform resource name，统一资源命名，是通过名字来标识资源**，但不指定如何定位资源

- 比如mailto:java-net@java.sun.com。













## 浏览器的安全策略

**同源策略**（最基础、最核心）：浏览器使用同源策略来**控制不同源之间的交互**【**并不是拒绝所有的跨域请求**】

**内容安全策略CSP**：**核心思想**是让**服务器决定**浏览器能够加载哪些资源，能否执行内联 JavaScript 代码

* 对第三方资源作出限制

**跨域资源共享 CORS**：可以进行**跨域访问控制**，从而使跨域数据传输得以安全进行

**跨文档消息机制**：可以通过 **window.postMessage** 的 **JavaScript 接口**来**和不同源的 DOM** 进行通信







# TCP相关

## TCP（传输控制协议）

**TCP是一种面向连接的单播协议**，在发送数据前，通信双方必须**建立连接**，提供了一种 **面向连接的、可靠的**、**基于字节流**服务

一个**TCP连接**由一个**4元组**构成，分别是**两个IP地址和两个端口号**。

> 所谓的“连接”，其实是**客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号**等。



## TCP的特性

TCP提供了一种 **面向连接的、可靠的**、**基于字节流**的服务

- **面向连接**：在发送数据前，通信双方必须在彼此间建立一条**连接**
- **可靠传输**：TCP通过一些特定**机制**来**保证数据可靠传输**【详见后面问题】
  - 如：**确认ACK和重传机制、数据校验机制、数据的合理分片和排序、流量控制、拥塞控制**
- **基于字节流**：TCP的窗口单位是字节，不是报文段
- **单播协议**，TCP中仅有两方进行彼此通信。

> TCP **不能保证数据一定会被接收到**，因为这是不可能的，它所提供的是**数据的可靠递送 和 故障的可靠通知**。



## UDP（用户数据报协议）

UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，不需要维护状态



## TCP 连接如何保证数据传输的可靠性

* **确认和重传机制** => 数据完整非重复

  * 接收方**收到报文就会发送ACK确认包**
  * 发送方在发送数据后**开启一个计时器**，如果一定时间内**没有收到ACK确认包**就会**重传**，直到发送成功为止（接受到ACK包）

* **数据校验**：**TCP校验和**（数据包的二进制相加后取反），发送方计算，接收方验证。如果接收方检测到校验和有差错，就会丢弃该段数据

* **数据合理分片和排序**：按照**MTU**对数据进行合理分片，每一个**数据包**会有对应的**编号**，**接收方会缓存未按序到达的数据**，最终**排序后**再交给应用层

* **流量控制**：利用**滑动窗口**实现**对发送方的流量控制**。

  * 接收方在ACK确认包中返回**接收窗口的大小**，控制发送方的发送速率，以免缓冲空间不足，来不及接受数据而导致丢包

* **拥塞控制：**让TCP在传输时**尽可能快的将数据传输**，并且避免拥塞造成的一系列问题

  * **慢启动**：**刚开始传输很慢**，先指数后线性增长（转点由**阙值**控制）
  * **拥塞避免**：拥塞窗口 >= 阀值时，指数**转为线性增长**，避免增长过快导致**网络拥塞**。
  * **快重传和快恢复 FRR**：接收到**连续的三个重复冗余ACK**（认为有丢失了），不需要等待**超时重传定时器溢出**（会要求传输暂停）就立即重发该报文段
    * **累计确认包**：当接收端收到比期望序号大的报文段时，便会重复发送最近一次确认的报文段的确认信号，我们称之为**冗余ACK**

  

## TCP和UDP的区别

TCP提供了一种 **面向连接的、可靠的**、**基于字节流**的服务，**单播协议**

**相比于TCP，UDP则是一个简单的面向数据报的通信协议**

* **连接**：TCP 面向连接，UDP 无连接
  * TCP面向连接，实际上是三次握手在**客户端和服务端之间初始化好了序列号**。只要满足TCP的四元组（源IP地址、目的IP地址、源端口、目的端口）+序列号，那客户端和服务端之间发送的消息就有效，可以正常接收。
* **可靠性**：TCP提供可靠的服务，保证**数据可靠，不丢失，按序到达**；而UDP尽最大努力交付，即不保证可靠交付，可能存在丢包。
  * TCP 为提供特定机制来保证可靠传输，如：**确认ACK和重传机制、数据校验机制、数据的合理分片和排序、流量控制、拥塞控制**
  * UDP需要**应用程序**根据自己的需求来进行重发处理
  * 关于拆包、粘包，丢包
    * UDP：当IP数据报**大于MTU**时，发送方的IP层就需要**把数据报分成若干片**，使每一片都小于MTU。接收方IP层需要进行**数据报的重组。**这样就会多做许多事情；而更严重的是，由于UDP的特性，**当某一片数据传送中丢失时**，接收方会因为无法重组数据报而丢弃整个UDP数据报。
    * TCP：会按MTU合理分片，**接收方会缓存未按序到达的数据**，重新排序后再交给应用层。
* **流模式与数据报模式**：TCP面向字节流，把数据看成一连串无结构的字节流；而UDP是面向报文的。
  * 流就是指**不间断的数据结构**，当应用程序采用 TCP 发送消息时，虽然可以**保证发送的顺序**，但还是犹如**没有任何间隔的数据流**发送给接收端
* **单播**：每一条TCP连接只能是**点到点的单播协议**；而UDP支持一对一，一对多，多对一和多对多的交互通信。

* **系统开销**：TCP对系统资源的要求较多，**首部开销20字节**；UDP的首部开销小，只有8个字节
* **流量控制**：**UDP没有流量控制**，因此**网络出现拥塞不会使源主机的发送速率降低**（对**实时应用**很有用，如IP电话，实时视频会议等）

---

> TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：
>
> * TCP 用于**在传输层有必要实现可靠传输**的情况；而在一方面，UDP 主要用于那些对**高速传输**和**实时性**有较高要求的通信或广播通信。
> * TCP 和 UDP 应该根据应用的目的按需使用。



## 三次握手

**第一次握手**：客户端向服务器端发送连接请求

**第二次握手**：服务器端收到客户端的连接请求，确认应答，并向客户端发送连接请求

**第三次握手**：客户端收到服务器端的连接请求，确认应答，三次握手结束

---

**作用**

1. **确定双方的收发能力是否正常**（第三次握手：**服务器的发送能力**是正常的、**客户端的接受能力**是正常的）

2. 传输一些**必要的信息**（IP地址、端口、序列号）

   

## 四次挥手

> **【注意】中断TCP连接的可以是客户端，也可以是服务器端。**

**第一次挥手**：**主动方请求关闭连接**，表示自己不再发送数据了（我不发送了，但是可以接受）

**第二次挥手：被动方表明自己接受到了主动方关闭连接的请求**，发送ACK**确认包**，但**还没有准备好关闭连接**（你不想发了，但是我还没发完！）

**第三次挥手**：**被动方请求关闭连接**（我发完了，你知道了我们就关了吧）

**第四次挥手：**主动方接收到来自被动方的关闭请求，**发送一个确认包**（我知道了我们都关闭吧）

* **被动方**接收到第四次握手的ACK确认包之后，**关闭连接**，进入CLOSED状态
* **主动方**没有等待到被动方的ACK，说明对方已经正常关闭连接，所以自己也关闭连接，进入CLOSED状态



## TCP 队头阻塞

**原因：**TCP连接传输数据中由于单个数据包的丢失而造成的阻塞

**TCP正常传输过程**：发送端的数据会被**拆分**为**有序的**小数据包，这些小数据包通过网络传输到了接收端，会**按序组合**成原始数据

![image-20200720185508050](D:\Uttues\Basic-knowledge\计算机网络\计算机网络相关.assets\image-20200720185508050.png)

**异常**：如果出现**数据丢包**，那么**整个 TCP 连接就会处于暂停状态**，需要**等待**丢失的数据包被重新传输过来。

![image-20200720185818531](D:\Uttues\Basic-knowledge\计算机网络\计算机网络相关.assets\image-20200720185818531.png)









# HTTP 相关

## HTTP协议（超文本传输协议）

HTTP协议是一个**应用层传输协议**，架构在TCP协议之上，它规定了**Web服务器与浏览器**之间**请求、应答的标准。**

* **工作过程**
  * 客户端与**web服务器**的HTTP端口（默认是80）建立一个**TCP套接字连接**
  * 通过TCP套接字，客户端向服务器**发送HTTP请求报文**
  * 服务端**接受请求并返回HTTP响应**：web服务器解析请求，定位请求资源，**将资源复本写到TCP套接字**，发送响应，由客户端读取。
  * 【HTTP/1.0】**释放TCP连接**：**Web服务器主动**关闭TCP套接字，释放TCP连接；**客户端被动**关闭TCP套接字，释放TCP
  * **客户端浏览器解析响应内容**

* **特点**：**无状态**、**明文协议**、请求-应答模型、可靠传输、灵活可扩展、服务端推送【端口号：80】
  * **灵活可扩展**：传输数据类型多样性，语义上的自由（定义了基本格式，其他部分无严格的语法限制）
  * **在HTTP2之前服务器端不能主动向客户端发送请求**



## 什么是Http无状态协议，怎么解决?

**HTTP无状态协议**

* HTTP无状态协议是指**协议对于事务处理没有记忆能力**，当客户端请求完成以后，再发送一次HTTP请求，服务器并不知道当前客户端是一个”老用户“。多次请求无法共享数据，无法跟踪用户的行为。
* **缺点：**如果后续处理需要前面的信息，则它必须**重传**，可能导致**每次连接传送的数据量增大**
* **优点**：如果服务器不需要先前信息，那么**应答就较快**，减少网络开销。

**解决方法：** **在URL地址栏拼接参数**，但是不安全； 使用**Cookie**； 使用**Session**



## HTTP的缺点

* **无状态**：对于事务处理没有记忆能力，如果后续处理需要前面的信息（登录状态），则必须**重传**，占用带宽
  * **另一方面也是优点**，在服务器不需要先前信息时**应答就较快**，减少网络开销。

- **明文传输**：协议里的报文（主要指的是头部）**不使用二进制数据**，而是**文本形式**。
  - **WIFI陷阱**：利用 **HTTP 明文传输**的缺点，诱导用户连上热点，抓取其传输数据，从而拿到敏感信息。

- **HTTP/1.1 的队头阻塞问题**



## HTTP 的队头阻塞

* **表现**：**HTTP/1.1**多个请求被放在任务队列中 **串行执行** ，必须 **等待前请求完成后才能去请求下一个资源**

* **原因**：HTTP 传输是**基于请求-应答的模式**进行的，**一发一收**（请求在任务队列中**串行执行**会发生阻塞）
* **解决路径**
  * HTTP/1.1 **管线化技术**、**并发连接**、**域名分片** 
  * HTTP 2 **多路复用**【TCP 队头阻塞】



## HTTP 报文结构

HTTP报文结构：**起始行 + 头部 + 空行 + 实体**

* **起始行**
  * **请求报文**的起始行：**方法 + 路径（URL） + HTTP版本**，`GET /home HTTP/1.1`
  * **响应报文**的起始行：**HTTP版本、状态码和原因**，`HTTP/1.1 200 OK
* **头部**：多种HTTP字段，有些是通用的，有些是请求头、响应头各自特有的【分隔符\r\n】
* **空行**：用来区分开`头部`和`实体 `  （如果说在头部中间故意加一个空行，那么空行后的内容全部被视为实体）
* **实体**：也就是body，存放具体数据。

---

> #### HTTP 报文格式注意事项
>
> * 起始行中，每两个部分之间用**空格**隔开，最后一个部分后面应该接一个**换行**
> * 头部：字段名**不区分大小写**，字段名**不允许出现空格**、**下划线`_`**，字段名后面必须**紧接着`:`**
>
> ![image-20200328113329438](D:\Uttues\Basic-knowledge\计算机网络\计算机网络相关.assets\image-20200328113329438-1595311420532.png)

---



### 响应头字段

* Set-Cookie：即将写入的Cookie信息
* Server：HTTP服务器的安装信息
* Content系列：表明服务器返回的数据类型、编码方式等
* 跨源服务器相关 - CORS
  * Access-Control-Allow-Origin：设置允许哪个请求域响应数据
  * Access-Control-Allow-Methods：指定请求域能够使用的请求方法
* 缓存相关
  * Cache-control
  * Expires
  * ETag
  * Last-Modified
  * Date：服务器生成数据的时间
* Accept系列：用于描述服务器端**可接受数据相关参数**
  * Accept：指定客户端能够接收的**内容类型**
  * Accept-Charset：  浏览器可以接受的**字符编码集**
  * Accept-Encoding ：  指定浏览器可以支持的web服务器返回内容压缩编码类型。
  * Accept-Language：浏览器可接受的语言  
* 分段范围请求相关
  * Accept-Ranges ：可以请求网页实体的一个或者多个子范围字段
  * Content-Range：每段数据相关信息【范围+长度】	
* Location：令客户端重新定向到的URI
* Allow：资源可支持的HTTP方法



### 请求头字段

* 缓存相关
* If-Modifie-Since
  * If-None-Match
* Content系列 ：用于描述客户端**发送数据的相关参数**
* ContentType
  * ContentEncoding
  * ContentLanguage
  * Content-Length  定长数据长度
* 分段范围请求相关
  *  Range 指定请求哪一部分  `Content-Range: bytes 0-9/96` 
* **User_Agent**：客户端设备类型
* **Connection: keep-alive**



### 请求头字段：Content-Type

Content-Type是一个**请求头参数**，决定了**发送的数据格式是以怎样一种编码方式传送的**。发送端也是根据Content-Type字段决定如何解析。

**Get请求：**无Content-Type，数据按**键值对**的形式拼接在url后面传送到后端。

**Post请求**：

* **用form表单提交**：Content-Type是通过**在form表单添加属性enctype**来确定的，可选值如下：

  * **application/x-www-form-urlencoded**（默认）：**form data里**，数据被编码成以 `'&'` 分隔的键-值对
  * **multipart/form-data**
    * **Request payload格式**，实际传送数据通过一个**boundary**分割符分隔的
    * 一般是有文件，图片等的上传时用

* **用ajax提交**

  * **application/x-www-form-urlencoded**（需要设置Content-Type请求头）

  * **multipart/form-data**

    * **不能手动设置Content-Type:'multipart/form-data'**
    * 参数需要通过var param = new FormData() 然后将参数param.append(key, val)
    * 可以上传键值对、也可以上传文件、图片

  * **appliction/json**

    * 以json的数据格式传输数据，支持比键值对复杂得多的结构化数据

  * **text 请求**：可以上传任意格式的文本，text/plain、text/json、text/html（中文不进行编码）

    

### 响应头字段：Accept系列

Accept系列：用于描述服务器端**可以接受的数据**相关参数： **数据格式**、**压缩方式**、**支持语言**和**字符集**等。

* Accept：指定服务器端能够接收的**数据类型**（比如文本、图片、视频音频、Json文件等）
  * Content-Type
* Accept-Encoding ：  指定服务器端能够接受的**数据压缩编码方式**（比如gzip）
  * Content-Encoding
* Accept-Language：指定服务器端能够接受的**语言**  
  * Content-Language
* Accept-Charset：  指定服务器端可以接受的**字符编码集**
  * Content-Type字段的 charset属性

* Accept-Ranges ：指定服务器端**允许客户端仅仅请求资源的一部分**【大文件传输，**分段请求**】
  * 处理范围请求时指定其值为bytes，反之则加上响应头Accept-Ranges: none





## HTTP 请求

HTTP1.0 定义了三种请求方法： **GET、POST 和 HEAD**方法。

HTTP1.1 新增了六种请求方法：**OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT**

| 序号 | 方法    | 描述                                                         |
| :--- | :------ | :----------------------------------------------------------- |
| 1    | GET     | 请求一个指定资源，用于获取数据，**并返回实体主体**。         |
| 2    | HEAD    | **类似于 GET 请求**，只不过返回的**响应中没有响应体**，用于**获取报头** |
| 3    | POST    | 向指定资源**提交数据**（例如**提交表单或者上传文件**）。数据被包含在**请求体**中。POST 请求可能会导致**新的资源的建立和/或已有资源的修改。**【不幂等】 |
| 4    | PUT     | 客户端向服务器**指定**资源位置**上传其最新内容**（**取代**整个旧数据）【幂等】 |
| 5    | PATCH   | 是对 **PUT 方法的补充**，用来**对已知资源进行局部更新** 。   |
| 6    | DELETE  | 请求服务器**删除指定的资源**。                               |
| 7    | OPTIONS | 返回**服务器针对特定资源所支持的HTTP请求方法**（预检请求）；也可以利用**向Web服务器发送'*'的请求来测试服务器的功能性**。 |
| 8    | TRACE   | 追踪请求-响应的传输路径，**回显服务器收到的请求，主要用于测试或诊断。** |
|      |         |                                                              |
| 9    | CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。    |



### OPTIONS请求的作用

使用CORS时，跨域请求会被分为简单请求和非简单请求

* 简单请求：get、head、设置特定Content-Type值的post
* 非简单请求：
  * 需预检的请求要求必须首先使用 `OPTIONS` 方法发起一个**预检请求**到服务器，以**获知服务器是否允许该跨域请求**。
  * "预检请求“的使用，可以**避免跨域请求对服务器的用户数据产生未预期的影响**



### GET和POST的区别

**表面：**

* **语义：**GET用于**请求指定资源**，POST用于**提交数据**
* **数据存放位置**：GET**参数通过URL传递**，POST携带参数存放于**请求体**中（表单产生的数据自动存放在body）

* **数据量**：GET**传送的数据量较小**，不能大于**2kb**【**本质上**是**URL长度的限制**】

* **编码方式**：GET请求只能进行**url编码**，而POST支持**多种编码方式**（enctype/contentType）
  * 本质是url编码和body编码的区别

* **是否幂等**：POST是**不幂等**的，不能多次执行，而GET是幂等的
* **回退**：GET在浏览器**回退时是无害的**，而POST会再次提交请求
* **缓存**：GET 请求会被**浏览器主动缓存**下来，留下历史记录，而 POST **默认不会**。

* **安全性：**GET比POST**更不安全**，因为参数直接暴露在URL上（会保存在历史记录），不能用来传递敏感信息

  * 从攻击的角度看**两者都不够安全**，Http是**明文协议**，最好用HTTPS进行端端加密

**根本区别**：**GET产生一个TCP数据包；POST产生两个TCP数据包。**

* 对于GET请求，浏览器会把http header和data一并发送出去，服务器响应200
* 对于POST，浏览器先发送header，服务器响应**100 continue**，浏览器再发送data，服务器响应200 ok
* **并不是所有浏览器都会在POST中发送两次包**，Firefox就只发送一次。

---

**相同点：**GET和POST都是HTTP协议中的两种发送请求的方法，**底层都是基于TCP/IP**（上述的所谓区别，只是浏览器厂家根据约定做的限制）



### GET比POST更加有效（只发送一次包）？

**POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效？**

* 如果**网络环境好**的话，发一次包的时间和发两次包的**时间差别**基本可以无视。如果**网络环境差**的话，两次包的TCP在验证**数据包完整性**上，有非常大的优点。
* GET与POST都有自己的**语义**，不能随便混用。 ---- REST api
* **并不是所有浏览器都会在POST中发送两次包**，Firefox就只发送一次。



## HTTP状态码

> 已参考MDN：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status

HTTP状态码为**三位数**，第一位表示状态码类型

**1XX：信息响应**——**表示当前处理的状态**

* **100 Continue 继续：**告诉客户端**部分请求已收到（已检查头部）**，客户端**应继续请求**。

  * **POST请求**，先发送http header，服务器端会返回 **100 状态码** 或者是 **417 状态码**
  * 前提：请求中包含Expect: 100-continue

* **101 Switching Protocols 协议切换：**表示服务器**应客户端升级协议的请求**正在进行协议切换（Websocket）

  ```js
  //使用WebSocket
  HTTP/1.1 101 Switching Protocols
  Upgrade: websocket 
  Connection: Upgrade
  ```

**2XX：成功——表示请求已被成功接收、理解、接受**

- 200 OK： **请求成功**，而成功的含义取决于HTTP请求方法
- 201 Created ： 请求成功，并且服务器**创建了新的资源**（一般在POST、PUT请求之后）
- 204 No Content： 服务器成功处理了请求，但**不需要返回任何实体内容**
- 206 Partial Content ：服务器**已经成功处理了 部分GET 请求**（请求资源的一部分），同时携带相应的响应头字段Content-Range
  - 使用场景： **HTTP 分块下载和断点续传**，
  - 该请求必须包含 **Range** 头信息来**指示客户端希望得到的内容范围**

**3XX：重定向——要完成请求必须进行下一步的操作**

* 301 Moved Permanently **永久重定向**，请求的网页已永久移动到新位置，**location**字段值为**重定向的URL**
  *  浏览器**默认会做缓存优化**
* 302 Found  **临时重定向**，即定位头信息中所给的**URL暂时不可用，临时重定向**，**默认不做缓存优化**
* 304 Not Modified： 在**协商缓存**中应用，表明资源未改变，缓存可用

**4XX：客户端错误——请求有语法错误或请求无法实现**

* 400 Bad Request  **语义有误**，当前**请求无法被服务器理解**，客户端不应当重复提交该请求；**请求参数有误**
* 401 Unauthorized **表示当前请求需要用户验证**，Basic身份认证、Token过期失效
  * 响应包含一个适用于被请求资源的 **WWW-Authenticate 响应头**用以弹窗询问用户信息
* 403 Forbidden **没有权限**访问此站，**服务器禁止访问**
* 404 Not Found **未找到**与 URI 相匹配的资源
* 405 Method Not Allowed: **请求方法**不能被用于请求相应的资源，返回一个**Allow头信息**给出**请求方法列表**
* 408 Request Timeout  **请求超时**。客户端**没有在服务器预备等待的时间内完成**请求的发送

**5XX：服务端错误——服务器未能实现合法的请求**

* 500 Internal Server Error 服务器遇到了不知道如何处理的情况，是**最常见**的服务器端错误。
* 501 Not Implemented: 表示**客户端请求的功能还不支持**
  * 只有GET和HEAD是要求服务器支持的，它们必定不会返回此错误代码。
* 503 Service Unavailable: **服务不可用**，因**暂时超载或临时维护**，当前服务器目前无法处理 HTTP 请求。
* 504 Gateway Timeout  当服务器**作为网关**，**不能及时得到响应**时返回此错误代码。





### 401状态码

1、与前后端鉴权中古老的方案**Basic身份认证**有关

2、token验证失败会返回401状态码

---

> **Basic身份认证过程：** 
>
> * **客户端向服务器发送请求**【假设客户端尚未被验证】
>
> * **质询（响应首部www-Authenticate）**：服务器返回**401状态码（未授权）**，表明服务器拒绝请求，没有按照请求返回对应资源，**希望用户提供用户名和密码**。同时携带**www-Authenticate**，对相应保护区域进行描述。
>   * **客户端**收到401状态码，并检测到响应头部www-Authenticate会**自动弹出用户名和密码输入界面**
>
> * **授权（请求首部Authentication）**： 用户输入用户名和密码后，客户端重新发送请求，并附加**请求首部Authentication**，用来说明认证算法，用户名和密码，用户名和密码用冒号分隔，并将用户名及密码**默认**以**base64加密方式**加密(base64不安全!)。
> * 服务器收到上述请求信息后，将Authorization字段后的**用户信息取出、解密**，将解密后的用户名及密码**与用户数据库进行比较验证**，如用户名及密码正确，服务器则根据请求，**将所请求资源发送给客户端**



### 403状态码

资源不可用，服务器理解客户的请求，但拒绝处理它。

通常由于服务器上文件或目录的**权限设置**导致，比如IIS或者apache设置了**访问权限不当**。

服务器想让客户端知道为什么没有权限的情况下，服务器应该在返回的信息中**描述拒绝的理由**。

在服务器**不想提供任何反馈信息**的情况下，服务器可以用**404 Not Found代替403 Forbidden**。



### 206状态码

HTTP请求字段range:

* 格式： Range: bytes=start-end
* 请求资源的部分内容（不包括响应头的大小），单位是byte，即字节，从0开始.
* 如果**服务器能够正常响应**的话，服务器会返回 **206 Partial Content 的状态码**及说明.
* 如果**不能处理这种Range**的话，就会**返回整个资源以及响应状态码为 200 OK** .



## HTTP 如何传输定长和不定长的数据？

### 定长包体

发送端在传输时一般会带上 **`Content-Length`,** 来**指明包体的长度**，然后**发送对应长度的数据**。

* Content-Length = 数据长度  正常显示
* Content-Length < 数据长度  数据被截断
* Content-Length > 数据长度  直接显示：网页无法正常运作

> `Content-Length`对于 http 传输过程起到了十分关键的作用，如果**设置不当会直接导致传输失败**。

### 不定长包体

发送端在传输时携带 **Transfer-Encoding: chunked**，表明**分块传输**，设置该字段后会自动产生两个效果:

- Content-Length 字段会被**忽略**
- 基于**长连接**持续推送动态内容，多次调用write接口发送数据 【长连接`Connection: keep-alive`】
- 响应体最后留有一个空行



## HTTP 如何处理大文件的传输？

> 如果一口气全部传输过来显然是不现实的，会有大量的等待时间，严重影响用户体验。

HTTP 针对大文件的传输的场景，采取了**范围请求**的解决方案，**允许客户端仅仅请求一个资源的一部分**。

1. 服务器加上响应头 **Accept-Ranges: bytes** 表示支持**范围请求**

2. 客户端通过请求头字段 **Range** 指定请求哪一部分 【单段、多段数据】

3. 服务器收到请求，验证范围**是否合法**，如果越界，返回`416`错误码，否则读取相应片段，返回`206`状态码。

4. 服务器端响应内容

   - `Content-Range`字段：每段数据相关信息【范围+长度】	

   * `Content-Type: multipart/byteranges; boundary=00000010101`，表示：
     * 请求是多段数据请求
     * 响应体中的分隔符是 00000010101



##  HTTP 中如何处理表单数据的提交？

> 由于表单提交一般是`POST`请求，很少考虑`GET`，因此这里我们将默认**提交的数据放在请求体**中。

在 http 中，有**两种主要的表单提交的方式**，体现在两种**不同的`Content-Type`取值**:

- application/x-www-form-urlencoded
- multipart/form-data

#### Content-Type：application/x-www-form-urlencoded

- 其中的**数据**会被编码成**以`&`分隔的键值对**
- 字符以**URL编码方式**编码。

```
// 转换过程: {a: 1, b: 2} -> a=1&b=2 -> 最终形式： "a%3D1%26b%3D2"
```

#### Content-Type：multipart/form-data

- 请求头中的`Content-Type`字段会包含**分隔符**`boundary`，其值由浏览器默认指定。
- **数据分段**，每两个部分之间通过**分隔符来分隔**，每部分表述均有 HTTP 头部描述**子包体**，如`Content-Type`，在最后的分隔符会加上`--`表示结束。
- 最大的特点在于：**每一个表单元素都是独立的资源表述**
- 如果是图片等**文件**的上传，基本采用`multipart/form-data`，没有必要做URL编码：性能消耗，占据空间

> 平时在写业务的过程中，看你并没有注意到其中还有`boundary`的存在，如果你打开**抓包工具**，确实可以看到不同的表单元素被**拆分**开了，之所以在平时感觉不到，是以为浏览器和 HTTP 给你封装了这一系列操作。



## HTTP协议的发展历程

### 超文本传输协议 HTTP/0.9

**需求**：在网络之间传递 HTML 超文本的内容（超文本传输协议）

**特点**：

* 客户端发送请求时只有一个请求行，无请求头、请求体
* 服务器不返回头信息（直接返回数据）
* 返回的文件内容是以 **ASCII 字符流**来传输的（都是 HTML 格式的文件）

![img](https://static001.geekbang.org/resource/image/db/34/db1166c68c22a45c9858e88a234f1a34.png)



### 被浏览器推动的 HTTP/1.0

**核心诉求**：支持**多种类型的文件下载**

> 在浏览器中展示的不单是 HTML 文件，还包括 JavaScript、CSS、图片、音频、视频等不同类型的文件
>
> 1. 浏览器需要知道服务器返回数据的数据类型、压缩方法、语言版本、编码类型

**特点**：

* 引入了**请求头和响应头**，以 Key-Value 形式保存，支持多类型文件传输、多编码等
  * 在请求头中还加入了**用户代理**的字段（服务器需要统计客户端基础信息）
* 引入了**状态码**，表明服务器最终处理该请求的情况
* 提供了 **Cache 机制**，用来缓存已经下载过的数据

![img](https://static001.geekbang.org/resource/image/b5/7d/b52b0d1a26ff2b8607c08e5c50ae687d.png)

```js
// 请求头（表明浏览器的期待，但服务端仍可以指定）
accept: text/html
accept-encoding: gzip, deflate, br
accept-Charset: ISO-8859-1,utf-8
accept-language: zh-CN,zh
// 状态码
content-encoding: br
content-type: text/html; charset=UTF-8
```

### 缝缝补补的 HTTP/1.1

#### HTTP/1.1 的改进

**长连接|持久连接** 

* **问题：**HTTP1.0 每次通信都需要经历**建立 TCP 连接、传输 HTTP 数据和断开 TCP 连接**，开销大
  * 页面更复杂了，需要引用的资源更多，开销大
* **表现：**在一个 TCP 上可以传输多个 HTTP 请求，只要浏览器或服务器不明确断开，TCP链接就会一直保持
  * **默认开启**，请求头上加入Connection: close可关闭长连接

**并发连接**

* **表现：**允许一个域名分配多个长连接（TCP），一个队列阻塞，其他队列还可继续（Chrome默认6个）

**域名分片**

* **表现**：引入CDN，一个域名下分出多个**二级域名**（一个域名6个长链接），指向同一台服务器【过时了！】

**不成熟的 HTTP 管线化（最终被浏览器厂商放弃）**

* **问题**：在长连接上依然存在**队头阻塞**问题
* **表现**：将**多个 HTTP 请求整批提交给服务器**【整批发送请求，但服务器依然需要根据请求顺序来返回响应】
* FireFox、Chrome 都做过管线化的试验，但是由于各种原因，它们最终都放弃了管线化技术。

**提供虚拟主机的支持 Host字段**

* 在 HTTP/1.0 中，**每个域名绑定了一个唯一的 IP 地址**，一个服务器只能支持一个域名
* 随着虚拟主机技术的发展，需要实现**在一台物理主机上绑定多个虚拟主机**（单独的域名，公用的 IP 地址）
* **表现**：在 HTTP/1.1 请求头新增 **Host 字段**，表示**当前域名地址**，这样服务器就可以根据不同的 Host 值做不同的处理

**引入 Chunk transfer 机制支持动态生成的内容**

* **问题**：HTTP/1.0 时，需要在响应头中设置**完整的数据大小**Content-Length（动态内容在**传输前难确定**），导致**浏览器不知道何时会接收完所有的文件数据**
* **表现**：服务器会**将数据分割成若干个任意大小的数据块**，每个数据块发送时会附上上各数据块的长度，最后使用一个零长度的块作为发送数据完成的标志

**客户端 Cookie机制**

**安全机制**



#### HTTP/1.1 存在问题：带宽利用率低

原因

* **TCP 的慢启动**：传输速度**先（非常）慢后快**【 TCP 为了减少网络拥塞的一种策略（但在并发连接下导致数据传输更慢了）】
* **多条TCP连接竞争固定的带宽**：带宽充足时，传输速度会慢慢增加；带宽不足时，这些 **TCP 连接就需要动态减慢接收数据的速度**（可能是关键资源）
* **队头阻塞**：一个TCP被多个HTTP请求复用（长连接）

---

> **带宽**是指每秒最大能发送或者接收的字节数
>
> * 上行带宽：每秒能发送的最大字节数
> * 下行带宽：每秒能接收的最大字节数



### HTTP/2

思路：**一个域名只使用一个 TCP 长连接（一次慢启动，不竞争带宽）和消除队头阻塞问题**

#### 多路复用（核心特性）

**作用**：充分利用带宽，最大限度规避了 TCP 的慢启动所带来的问题

**实现原理：**通过**引入二进制分帧层将请求分成一帧一帧的数据去传输**，来实现 HTTP 的多路复用技术，实现资源的**【并行传输】**

* 客户端请求**经过二进制分帧层处理**后，会被转换为一个个**带有请求 ID 编号的数据帧**，通过协议栈将这些帧发送给服务器【每个请求都有一个对应的 ID】
* 服务器接**收到所有帧**之后，会将所有**相同 ID 的帧合并为一条完整的请求信息**，并**处理该请求** **【可以优先处理关键资源的请求，优先级高】**
* 服务器**将处理后的响应行、响应头和响应体分别发送至二进制分帧层**，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。
* 浏览器接收到返回的**响应帧**之后，会**根据 ID 编号将帧的数据**返回给对应的请求。

![image-20200720184848771](D:\Uttues\Basic-knowledge\计算机网络\计算机网络相关.assets\image-20200720184848771.png)



#### 其他特性

* **可以设置请求的优先级**（关键资源）
* **服务端推送**：HTTP/2 可以直接**将数据推送到浏览器**（如果服务器知道该 HTML 页面会引用哪些关键资源，就可以在 HTML 请求之后，将关键资源一并发送）

* **头部压缩**：减少传输数据的大小



#### HTTP/2 存在问题

**TCP队头阻塞**

- 在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果**其中任意一路数据流中出现了丢包**的情况，那么就会**阻塞该 TCP 连接中的所有请求**。
- 随着**丢包率的增加**，HTTP/2 的**传输效率也会越来越差**

**TCP 建立连接会产生网络延时**

* 建立TCP连接，需要进行三次握手（消耗 1.5 个 RTT ）
* 进行 TLS 连接也需要经过一次握手过程（大致是消耗 1～2 个 RTT ）需要 1～2 个 RTT

---

> 网络延迟又称为 RTT（Round Trip Time）：从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间（反映网络性能的一个重要指标）

**TCP 协议僵化：很难改进**

* 中间设备的僵化（物理设备）
* 操作系统的僵化（通常操作系统的更新都滞后于软件的更新）



### HTTP/3

**QUIC 协议：**基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能 【中间设备僵化：只认TCP、UDP】

![image-20200720191556609](D:\Uttues\Basic-knowledge\计算机网络\计算机网络相关.assets\image-20200720191556609.png)

#### QUIC 协议的功能

* 实现了类似 TCP 的**流量控制、拥塞控制、可靠传输、数据包重传等**的功能。

* 集成了 **TLS 加密功能**。相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。

* **多路复用**功能。**和 TCP 的思路不同**，QUIC 实现了**在同一物理连接上可以有多个独立的逻辑数据流**（数据流的单独传输）

* **快速握手**：QUIC 是**基于 UDP** 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接

  ![image-20200720191850884](D:\Uttues\Basic-knowledge\计算机网络\计算机网络相关.assets\image-20200720191850884.png)

#### HTTP/3 的挑战

* 服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持
* 部署 HTTP/3 存在着非常大的问题（系统内核对UDP的优化不足）
* 中间设备僵化。中间设备对 UDP 的优化程度远远低于 TCP









# Cookie相关

## Cookie 简介

**HTTP Cookie**是当用户浏览网站时，**服务器返回响应**并保存在**本地**（客户端）的一个**小的纯文本文件**，一个由**键值对**构成的**字符串**。

* **同源限制**。一个网站只能读取它自己的cookie，不能读取其他非同源网站的Cookie文件，
* **应用场景：**
  - 会话状态管理（如**用户登录状态**、**购物车**、**游戏分数**或其它需要记录的信息）
  - 个性化设置（如用户**自定义设置、主题**等）
  - 浏览器行为跟踪（如**跟踪分析用户行为**等）
* 会**被滥用为本地存储**（Cookie会**自动携带**在请求中发送给服务器端，会**增加网络开销，浪费带宽**）



## Cookie 工作过程

* 客户端**第一次**发送请求，**服务器**响应时**在头部response headers中用set-cookie字段来唯一地标识用户**，最终**cookie**会变成存储在用户机器硬盘里的**小文本文件**

* 客户端下一次发送网络请求时，浏览器会**自动**把**对应的cookie放到请求头一起提交给服务器** **【弥补了HTTP无状态的缺陷】**
  * **每一次发送Http请求时浏览器都会检查是否有对应cookie**
* 服务器会**根据cookie**辨认用户，若成功则可直接进入，不必登录等。

> HTTP 是一个**无状态**的协议，每次 http 请求都是独立、无关的，默认不需要保留状态信息。



## 如何查看Cookie

* 在控制台/JS文件中直接**输入：document.cookie来查看cookie**【只能获取**非 HttpOnly 类型**】，返回键值对字符串，分割后遍历

* 开发者工具：**Application -> Storage -> Cookie** 【可以查看所有Cookie及其属性】



## cookie的属性

**生命周期**：**Expires、Max Age** —— 设置过期时间（过期删除，不会被发送）

* 设置了就是**持久化Cookie**，存放于**磁盘**中  `setMaxAge()`
* 不设置过期属性则表示是**会话Cookie**，存放于**内存**中，当会话结束（浏览器关闭时），cookie消失

**作用域**：**Domain**和**path** —— 给 **Cookie** 绑定域名和路径 `setDomain() setPath()`

* 满足 **同/子域+同/子路径+同源 **才可以访问该cookie

**大小**：**size** --- 设置cookie大小

**安全性**：**Secure** 和 **HttpOnly**、**SameSite**

* **Secure**：设置**Cookie只能在确保安全的请求中才能发送|修改**【HTTPS/其他安全协议下】【默认不含】
* **httpOnly**：设置cookie**是否能通过 Javascript 去访问**。【预防XSS攻击时Cookie被读取】【默认不含】
* **SameSite**：**限制第三方 Cookie的行为**，减少安全风险【防止 CSRF 攻击和用户追踪】【新增】

> ---
>
> ### 第三方Cookie是什么
>
> * 如果 **Cookie 的域**和**页面的域**相同，这个 Cookie 为**第一方 Cookie**（first-party cookie），
> * 如果 Cookie 的域和页面的域不同，则称之为**第三方 Cookie**（third-party cookie）。



## cookie的设置、读取、删除方法

* **服务端设置cookie**：set-cookie字段
* **客户端设置cookie**：document.cookie，自行封装



## cookie的优缺点

**优点**：人性化使用体验，不必反复输入密码；**弥补了HTTP无状态的缺陷**；供站点统计访问人数等

**缺点**

* **性能**：**每次**HTTP请求时cookie都会被浏览器**发送到服务端**（不管需不需要），**消耗带宽**
* **容量**：**每个特定域名下的cookie数量有限**

* **存储量**：cookie**存储量小，只有4KB**；
* **可操作性**：**需要自己封装**获取、设置、删除cookie的方法
* **中文需转码**：Cookie数据**存储中文需要转码**，浏览器默认iso8859
* **安全性**：
  * **多人共用一台电脑**带来了**不安全**因素
  * 另外，在`HttpOnly`为 false 的情况下，Cookie 信息能**直接通过 JS 脚本**来读取，可能引起**XSS攻击**
  * **Cookies欺骗**：由于 Cookie **以纯文本的形式**在浏览器和服务器中传递，很容易被非法用户**盗取、修改、伪造**Cookies的内容，在有效期内又会重新发送给服务器，这是相当危险的。 



## Session和Cookie的区别

**相同点：**都是**针对单独用户**的对象，不同用户在访问时会有各自的session或者cookies，不同用户之间互不干扰。

**不同点：**

* **存储位置不同**
  * session在**服务器端**产生，比较安全，但是**session多了会影响性能**
  * cookies在**客户端产生**，安全性稍弱，**请求资源时可能影响性能**

* **生命周期不同**
  * session生命周期 **在指定的时间** 后会结束，**不到指定的时间，也会随着浏览器进程的结束而结束**。Session**只能在本阅读器窗口以及其子窗口内有效**。
  * cookies默认也**随着浏览器进程结束而结束**，但如果**手动**指定时间，则不受浏览器进程结束的影响。

* **存储数据不同**
  * Cookie **只能保管ASCII字符串**，假如需求存取Unicode字符或者二进制数据，需求**先进行编码**。
  * Session中能够存取**任何类型**的数据

* **隐私策略的不同**
  * Cookie存储在**客户端**中，对客户端是**可见的**，可能被窃取、复制等
  * Session存储在**服务器**上，对客户端是**透明的**，不存在敏感信息泄露的风险。

* **服务器压力不同**
  * Cookie保管在客户端，**不占用服务器资源**。假如并发阅读的用户十分多，Cookie是很好的选择
  * Session是保管在服务器端的，并发访问的用户十分多，**产生大量session，耗费内存**
  * 像Google、Baidu、Sina这样并发访问量极高的网站选择cookie来追踪客户会话的。
* **跨域支持不同**
  * Cookie支持跨域名访问，例如将domain属性设置为“.biaodianfu.com”，则以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。跨域名Cookie如今被普遍用在网络中，例如Google、Baidu、Sina等。
  * Session则不会支持跨域名访问。Session仅在他所在的域名内有效。

> 假如选用Cookie，**比较好的方法**是，敏感的信息如账号密码等尽量**不要写到Cookie中**，或者是像Google、Baidu那样**将Cookie信息加密**，**提交到服务器后再进行解密**，保证Cookie中的信息只要本人能读得懂。



## Cookie新增属性：Samesite

Cookie 的`SameSite`属性用来**限制Cookie在第三方站点请求中的行为**，减少安全风险，用于**防止 CSRF 攻击和用户追踪**

SameSite可以设置为三个值，**Strict、Lax和None。**

* 在**Strict模式**下，如果是从第三方站点发起的请求，让浏览器**完全禁止在请求中携带某些关键 Cookie 数据到服务器**
  * 如果从站点A访问站点B的资源，则请求中不会携带上带有SameSite = Strict的Cookie，只有从站点B去请求站点B的资源时才会携带这些Cookie
* 在**Lax模式**，相对宽松一点，但有从第三方站点**以 get 方法提交表单**或**者a 标签发送 get 请求**的情况下可会带 Cookie，其他情况均不能。
* 在**None模式**下，也就是**默认模式**，请求会**自动携带上 Cookie**【并不属于跨域读操作】。

```js
set-cookie: 1P_JAR=2019-10-20-06; expires=Tue, 19-Nov-2019 06:36:21 GMT; path=/; domain=.google.com; SameSite=none
```







# HTTPS 相关

## 相关概念

**对称密钥：**加密跟解密用的是同一个密钥

* 用密钥加密消息之后，**将消息、密钥同时发送出去**，便于接收方解密使用
* **弊端**：密钥可能被**中间人拦截**，传输的消息依然可能会被窥探/修改

**非对称密钥**（一对）：私钥加密的数据，对应公钥解；公钥加密的数据， 对应私钥解

* 接收方将自己的公钥发送给发送方，**让发送方用公钥对消息进行加密**，接收方用自己的**私钥解**
* **好处**：传输的内容即使被拦截了也不能被破解，只有接受方能解密
* **弊端**
  * 非对称加密**效率低**；
  * 公钥被拦截篡改后，加密后的数据私钥解不了
  * 公钥可能被拦截，这样子的话私钥加密的数据在传输时依然会被窃取

**对称密钥+非对称加密**

* 使用 **非对称加密（RSA）** 的方法 来发送**加密算法的对称密钥**（只有接收方知道怎么解密），之后就可以使用这个对称密钥来进行通信了

---

**中间人攻击**：HTTP传输数据（客户端 - 服务器）时，将 HTTP 数据提交给 TCP 层之后，数据会经过用户电脑、WiFi 路由器、运营商和目标服务器，在这中间的每个环节中，这些数据很容易被中间人**窃取、伪造和篡改**，就称之为**中间人攻击**。

* **用户电脑**被黑客安装了**恶意软件**，那么恶意软件就能抓取和篡改所发出的 HTTP 请求的内容
* 用户一不小心连接上了 **WiFi 钓鱼路由器**，那么数据也都能被黑客抓取或篡改。
* 在加密算法中，中间人可以**拦截公钥**，并对拦截到的公钥**进行篡改**（假公钥加密的消息，真私钥无法解）

![img](https://static001.geekbang.org/resource/image/11/e2/118ced11537bd1e257f8df09380f33e2.png)

**确认身份 —— 数字证书：证明服务器的身份，证明公钥是服务器的公钥**

* 数字签名和原始信息合在一起称为数字证书，根据数字证书，可以去CA机构证实：公钥是真的

![image-20200406215650386](D:\Uttues\Basic-knowledge\计算机网络\计算机网络相关.assets\image-20200406215650386.png)

![image-20200406215758552](D:\Uttues\Basic-knowledge\计算机网络\计算机网络相关.assets\image-20200406215758552.png)



## HTTPS协议（安全套接字层超文本传输协议）

**HTTPS在HTTP的基础上加入了SSL协议**（也就是**安全套接字层**，Secure Socket Layer）来保证数据传输的安全

![image-20200722094035940](D:\Uttues\Basic-knowledge\计算机网络\计算机网络相关.assets\image-20200722094035940.png)

通常 HTTP 直接和 TCP 通信，HTTPS 则**先和安全层通信，然后安全层再和 TCP 层通信**。也就是说 HTTPS 所有的**安全核心都在安全层**，它**不会影响到上面的 HTTP 协议，也不会影响到下面的 TCP/IP**

---

> HTTPS就是HTTP的安全版，以SSL协议为安全基础，**对传输层数据进行加密**，依靠**证书**来**验证服务器的身份**

* HTTPS是**现行架构下最安全的解决方案，不是绝对安全**，但它也大幅**增加了中间人攻击的成本**
* **端口号：443**
* **传输层**：意味着站点使用了**HTTPS加密**之后，还是能够用firebug之类的软件查看到提交到的信息，显示**明文密码**（本地数据）。原因就是HTTPS（SSL）加密是发生在应用层与传输层之间，**在传输层看到的数据才是经过加密的**，而我们捕捉到的HTTP POST，是**应用层的数据**，此时还没有经过加密。



## HTTPS的握手过程

HTTPS在传输数据之前**需要客户端与服务端进行一次握手**：目的是在握手中**确立双方加密传输数据的密码信息**。

> **HTTPS的握手过程：**
>
> 1. 浏览器将 **自己支持的对称加密方法列表、非对称加密方法列表、Hash算法列表** ，生成的 **client-random 随机数** 发送给服务器。
> 2. **服务器**，从列表中**选出一种对称加密算法、非对称加密算法、Hash算法**，保存client-random 随机数。将所选的**算法**、生成的 **service-random 随机数** ，以及**数字证书**发送给客户端
>    - 证书里面包含了服务器的身份信息、网站地址，**加密的公钥**，以及**证书的颁发机构**等信息（证明服务器身份、传输公钥）
>    - 发送公钥的**目的**是：**客户端**验证后，**用公钥来加密对称密钥**，并发送给服务器，服务器可以**用私钥解开**
> 3. 客户端**获得网站证书**后
>    - **验证证书的有效性**，如果证书受信任，则浏览器栏里面会显示一个**小锁头**，否则弹出**证书警告框**
>    - **证书受信任** 或 用户**接受了不受信任的证书**， **客户端会生成一串 随机数pre-master**，并**用证书中的公钥加密**。
>    - 客户端**用（client-random|service-random|pre-master）共同计算对称密钥master-secret**，用于**加密**
>    - 客户端用master-secret来**对握手消息进行加密**，使用约定好的**HASH算法计算握手消息**，并将 （加密后的握手消息、Hash算法计算结果、公钥加密后的pre-master）发送给服务器
> 4. **服务器**接收客户端发来的数据之后要做以下的操作：
>    1. **用私钥将信息解密取出 pre-master**，使用（client-random|service-random|pre-master）共同计算**对称密钥master-secret**
>    2. 用对称密钥master-secret解密浏览器发来的**握手消息**，并借助**Hash算法**看看解密得到的握手消息是否与浏览器发来的一致**（验证数据完整性）**
>    3. 用**对称密钥master-secret加密一段握手消息，Hash处理后**，发送给浏览器。
> 5. 浏览器解密并计算握手消息的HASH如果与服务端发来的HASH一致，此时**握手过程结束**，之后所有的通信数据将由**master-secret**进行加密。
>
> ---
>
> client-random|service-random|pre-master，最终是双方都有的，用于**计算对称密钥**，并且pre-master用公钥加密，意味着黑客无法窃取对称密钥

* **确认加密算法的过程使用的是非对称性加密**
* **数据传输过程使用对称性加密**
* **HASH算法用于验证数据的完整性**



## 数字证书相关

### 为什么需要有数字证书

黑客可以通过**DNS挟持**来将站点A的IP地址换成自己恶意站点的IP地址，在自己的站点上采用公钥私钥，如此一来客户端并不知道自己访问的是哪个服务器

=> 服务器需要证明“我就是我”

**作用**：向浏览器证明服务器的身份，传递服务器公钥。



### 如何申请数字证书

1、准备一套**私钥和公钥**，私钥留着服务器自己使用

2、向 CA 机构提交公钥、公司、站点等信息并**等待认证**，这个认证过程可能是**收费**的；

3、CA 通过线上、线下等多种渠道来**验证**极客时间所提供**信息的真实性**，如公司是否存在、企业是否合法、域名是否归属该企业等

4、如信息审核通过，CA 会向站点**签发认证的数字证书**，包含了公钥、组织信息、CA 的信息、有效时间、证书序列号等，这些信息都是**明文的**，同时包含一个 **CA 生成的数字签名**。

> **数字签名的生成（数字证书的核心：CA私钥加密的数字签名，用于验证）：**
>
> 1. CA 使用 **Hash 函数**来计算极客时间提交的**明文信息**，并**得出信息摘要**；
> 2. CA 再使**用CA的私钥对信息摘要进行加密**，最终加密的结果就是数字签名



### 浏览器如何验证数字证书

1、浏览器读取证书中相关的**明文信息**，采用 CA 签名时相**同的 Hash 函数**来计算并得到**信息摘要 A**；

2、然后再利用**对应 CA 的公钥**解密数字签名数据，得到**信息摘要 B**；

3、**对比信息摘要 A 和信息摘要 B**，如果一致，则可以确认证书是合法的，即证明了这个服务器是极客时间的；同时浏览器还会验证证书相关的域名信息、有效时间等信息。

> 浏览会验证CA是否可靠：CA链 - 操作系统内置 CA 对应的证书称为根证书，根证书是最权威的机构，它们自己为自己签名，我们把这称为自签名证书。



## HTTPS的优点

- **认证用户和服务器**，确保数据发送到正确的客户机和服务器（CA证书）
- **对传输层的数据进行加密**，以防止数据在传输中途被窃取（客户机、服务器端是明文）
- 维护**数据的完整性**，确保数据在传输过程中不被改变（HASH算法）

---

- **SEO排名优化**：采用HTTPS加密的网站在**谷歌搜索**结果中的排名将会更高（有些钓鱼网站也这么做）
- 如果用户不小心访问**钓鱼网站**，浏览器可能会**警告SSL证书无效或过期**；所以及时安装SSL证书也可以帮助用户**确认网站真实性**（证明自己是真的网站~~手动滑稽~）

> 前三个是SSL证书的工作任务



## HTTPS的缺点

* 握手阶段**费时间，耗电**
* HTTPS**连接缓存不如HTTP高效**，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响
* **SSL证书需要钱**，功能越强大的证书费用越高；且通常**需要绑定IP**，不能在同一IP上绑定多个域名
* **HTTPS也并非绝对安全**：
  * HTTPS协议的**加密范围有限**，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。
  * 最关键的，**SSL证书的信用链体系并不安全**：在某些国家可以控制CA根证书，故中间人攻击也可行



## **SSL协议**

**SSL（Secure Sockets Layer，安全套接字层）**是一种安全协议，在客户端和服务器之**间创建一个安全连接**，确保在**客户机与服务器之间传输的数据（传输层）**是安全的。

要使服务器和客户机使用 SSL 进行安全的通信，**服务器**必须有两样东西：

* 密钥对：包括**一个公钥和一个私钥**
* 证书：用来进行 **身份验证**。

#### **SSL工作任务**

* **认证用户和服务器**，确保数据发送到正确的客户机和服务器（客户机、服务器端是明文）
* **加密数据**以防止数据中途被窃取；
* 维护**数据的完整性**，确保数据在传输过程中不被改变。

#### SSL工作过程

SSL 使用**安全握手**来初始化客户机与服务器之间的安全连接。

* 客户端**使用HTTPS的URL访问Web服务器**，要求与Web服务器建立SSL连接。
* **在握手期间**
  * **Web服务器**收到客户端请求后，会将**网站的证书信息（包含公钥）**传送一份给客户端
  * 客户机**使用服务器证书验证服务器**
  * 客户端与Web服务器开始协商SSL连接的**安全等级**，也就是信息加密的等级、加密方法等
  * 客户端根据双方同意的安全等级，**建立会话密钥**，利用网站的公钥将会话密钥加密，传送给网站。
  * Web服务器**利用自己的私钥解密出会话密钥**。
* 握手之后，SSL 被用来加密和解密 **HTTPS请求和服务器响应中的所有信息**，包括：客户机正在请求的 URL、提交的[表单](https://baike.baidu.com/item/表单)的内容、访问授权信息（比如用户名和密码）、所有在客户机与服务器之间发送的数据。



## HTTP和HTTPS的区别

* HTTP 的 **URL** 以http:// 开头，而HTTPS 的URL 以https:// 开头
* HTTP **明文传输**，是不安全的；而 HTTPS 通过 SSL\TLS  对**传输的数据进行加密**
* HTTP **标准端口**是80 ，而 HTTPS 的标准端口是443
* 在OSI 网络模型中，**HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层**
* HTTP无需证书，而HTTPS 需要**到CA机构申请SSL证书**（免费证书很少，一般需要交费）。
* **HTTPS费钱（SSL整数）费时（握手）**









# HTTP代理相关

## HTTP代理是什么

> HTTP 是**基于请求-响应模型**的协议，一般由**客户端**发请求，**服务器**来进行响应。

HTTP的代理服务器**既是Web服务器又是Web客户端**。

* 客户端向代理服务器发送请求。代理服务器像Web服务器一样，**接受来自客户端的请求**，正确地处理请求和连接，然后返回响应。
* 代理服务器**向服务器发送请求**。其行为就必须像正确的HTTP客户端一样，要发送清求并接收响应。



## HTTP代理/Web代理的作用

- **负载均衡**。代理服务器拿到**客户端请求**后，可以**通过特定的算法分发给不同的源服务器**，让各台源服务器的**负载尽量平**均。【**随机算法**、**轮询**、**一致性hash**、**LRU**`(最近最少使用)`等】
- **保障安全**。
  - 利用**心跳机制**监控后台的服务器，一旦发现**故障机**就将其踢出集群。、对于上下行的数据进行过滤
  - 对非法 IP 限流
- **缓存代理**。**将资源缓存到代理服务器**，使得客户端可以**直接从代理服务器获得**而不用到源服务器那里【Cache-Control: public】



## HTTP代理 相关头部字段

- **Via**：记录 HTTP 传输中报文传达的**代理服务器的顺序**【请求头、响应头中都有】
- **X-Forwarded-For：**为谁转发，记录**请求方**的`IP`地址（可能是代理服务器做请求方）
- **X-Real-IP**：获取**用户真实 IP** 的字段，不管中间经过多少代理，这个字段始终记录**最初的客户端的IP**。
- **X-Forwarded-Host**：**客户端**的域名
- **X-Forwarded-Proto**：**客户端**的协议



## X-Forwarded-For产生的问题

X-Forwarded-For 表示为谁转发，记录的是**请求方的 IP**，意味着**每经过一个代理，这个字段的名字都要变**

**产生两个问题**：

* 意味着代理必须**解析 HTTP 请求头**，然后**修改**，比直接转发数据**性能下降**。

* 在 **HTTPS 通信加密**的过程中，**原始报文是不允许修改的**。

**解决方法：**代理协议。**在 HTTP 请求行上一行**加上：

​                      **PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求端口 + 接收端口**

```js
PROXY TCP4 0.0.0.1 0.0.0.2 1111 2222
GET / HTTP/1.1
```













# HTTP缓存相关

## 浏览器缓存是什么？

* 缓存是一种**保存资源副本**并**在下次请求时直接使用该副本**的技术
* 浏览器缓存就是**浏览器请求网站留下的资源副本**



## HTTP/浏览器缓存策略

根据响应头,浏览器缓存策略一般分为三种：**强缓存**、**协商缓存**和**启发式缓存**。（根据优先级顺序）

强缓存：【expired】【Cache-Control的max-age】——**直接减少请求数，是提升最大的缓存策略**

协商缓存：【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】——**可能可以通过减小响应提交来优化性能**

启发式缓存：【Date】和【Last-Modified】



#### 强缓存

强缓存主要是**通过http响应头中的Cache-Control和Expires**两个字段控制，**给浏览器缓存设置过期时间**，过期意味着浏览器需要重新请求。

1. **HTTP/1.0时期**，使用的是**Expires**，设置的是来源于服务器的**绝对时间**
2. **HTTP/1.1时期，**使用的是**Cache-Control中的max-age**，设置的是**具体缓存时间长度**【max-age优先级高】

* 浏览器表现为**200状态码**（from memory | dist cache）
* 强缓存的**局限性**：资源在服务器端更新
* **强制缓存直接减少请求数，是提升最大的缓存策略。** 



#### 协商缓存（对比缓存）

协商缓存是利用的【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header字段。

**过程：**客户端**第一次**向服务器发送请求，服务器在返回资源时，在**响应头**中加上 Last-Modified | ETag；当客户端**下一次**发送请求时，就会在**请求头**中加上 If-Modified-Since | If-None-Match 字段，字段的内容也就是上一次服务器返回资源时携带的相关字段内容，服务器端接受请求后，根据字段内容来**分析资源**是否更新：

* 如果资源未更新，服务器返回**304状态码**，那么**浏览器则会从缓存中读取资源**； 
* 若资源已更新，服务器返回**200状态码**，重新返回最新资源

> 两组字段的区别在于，一组是根据资源更新时间来判断，另一组是根据资源内容来判断（具体辨析见下文）

协商缓存**解决了强缓存无法及时获取更新资源的问题**。



#### 启发式缓存

* 如果请求头中**没有确定缓存过期时间**的字段，此时则会默认触发浏览器**启发式缓存**
* 浏览器根据**响应头**中2个时间字段 **Date 和 Last-Modified 之间的时间差值**，取其值的**10%**作为缓存时间周期。





## HTTP缓存流程总结

> **强缓存和协商缓存并不是二选一的！**协商缓存作为**强缓存失效后的一种后备方案**。

---

1. 首先通过 `Cache-Control` 验证**强缓存是否可用**：如果强缓存可用，直接使用
2. 否则进入**协商缓存**，发送 HTTP 请求，携带头部字段 If-Modified-Since | If-None-Match
3. 服务端根据请求字段检查资源是否更新，返回 200 | 304（使用强缓存中的过期版本）



## 缓存相关HTTP头部字段

`Cache-Control` 

强缓存：`expires`  `Cache-Control /  Max-Age`

协商缓存：`Last-Modified`  `If-Modified-Since`   `ETag`  `If-None-Match`

启发式缓存：`Last-Modified`  `Date`

历史遗留：`pragma`



## 强缓存中两个头部字段的区别

【Expires】**：缓存的绝对过期时间**

* **写法复杂**。表示时间的字符串多个空格，少个字母，都会导致非法属性从而设置失效。
* Expires**返回的是服务器的时间**，但**判断的时候用的却是客户端的时间**【用户有可能改变客户端的时间，导致**缓存时间判断出错**】
  * 引入Cache-Control:max-age指令的原因之一

【HTTP1.1：cache-control: max-age】**：缓存的相对过期时间**，相对于缓存的开始时间

---

**优先级：**`max-age>Expires`。当两者同时出现在响应头时，**Expires将被max-age覆盖.**（需要都加，**兼容**）



## 协商缓存中的两组头部字段的优缺点

* **精确度**
  * **【ETag、If-None-Match】**是按照内容给资源上标识，可以**更加准确**的判断文件内容是否被修改。
  * **【Last-Modified，If-Modified-Since】没法准确的判断**资源是否真的修改了
    * Last-Modified是**以秒为单位进行更新**，如果在1秒内频繁更改了多次，Last-Modified检验不出来
    * **编辑**了资源文件，但是文件内容**并没有更改**，用 Last-Modified 也会造成缓存失效
* **性能**：Last-Modified 优于 ETag，因为ETag需要**对资源进行生成标识（哈希值）**，**性能**方面就势必有所牺牲；而 Last-Modified 仅仅只是**记录一个时间点**
* **优先级**：ETag优先级高于 Last-Modified
  * 一般情况下这两个头部字段**都要传给服务器端**，由服务器来**根据资源特点**决定选择哪一对header，因为etag更准也不意味着更好用，存在性能消耗。

---

#### 有了last modified 为什么 还要ETag（同时需要）？

* last modified的局限性：**无法准确的判断资源是否真的修改了**【比较内容的修改时间】
  * Last-Modified是**以秒为单位进行更新**，服务器不一定能精确判断修改时间
  * **编辑**了资源文件，文件内容**并没有更改**，此时Last-Modified 会造成缓存失效
* ETag依赖后台相关算法生成资源的唯一标识，**更加准确**，但需要生成标识，**有性能消耗**【比较内容的特征值】
  * **不一定就好用**，对于**一些图片等静态文件的修改**，如果每次都生成 ETag 来比较，显然要比直接比较修改时间慢很多
* 将Etag和lastModified同时传入服务器时，服务器可以**根据自己缓存机制的需要**，来选择缓存判断的依据（选一个）



## no-cache & no-store

no-cache：可以缓存，但每次**使用缓存前都应去向服务器验证缓存是否可用**，也就是直接进入**协商缓存阶段**。

no-store：无论如何不缓存，内存缓存也不。



## Cache-Control: max-age=0 & no-cache

* `max-age=0`是告诉客户端资源的缓存到期**应该**向服务器验证缓存的有效性。
* `no-cache`则告诉客户端使用缓存前**必须**向服务器验证缓存的有效性。



## Etag存的是什么

ASCII字符串



## HTTP代理缓存相关

### HTTP代理缓存

**缓存代理**机制：**让代理服务器接管一部分的服务端HTTP缓存**，客户端缓存过期后**就近**到代理服务器缓存中获取，**代理缓存过期**了才去向源服务器发出请求，这样在流量巨大的时候能**明显降低源服务器的压力**。



### HTTP代理缓存相关字段

**源服务器**：**响应头**加上 **Cache-Control 字段**进行缓存控制

* **private 和 public**  指定是否允许代理服务器缓存

* **proxy-revalidate**：表示**代理服务器**的缓存过期后会到源服务器获取。

* **s-maxage ** 限定了**缓存在代理服务器中的缓存时长**

**客户端**：**请求头**

* **max-stale ** 数值m，表示过期后m时间内仍可获取缓存（宽容）
* **min-fresh** 数值m，表示只能在过期时间内的m时间之前才能获取缓存（限制）
* **only-if-cached**：表示客户端**只会接受代理缓存**，而**不会接受源服务器的响应**。











# 同源策略与跨域相关

## 同源策略

**同源：** **协议、端口、域名**相同，则这两个URL同源

**同源策略：**浏览器使用同源策略来**控制不同源之间的交互**（**并不是拒绝所有的跨域请求**）

* **限制（跨域读操作）**
  * DOM：禁止来自不同源的 JavaScript 脚本**对DOM 对象读和写** | **获取Javascript对象**
  * 数据：限制了不同源的站点**读取 Cookie、IndexDB、LocalStorage** 等数据
  * 网络：限制了不同源的站点之间通过 XMLHttpRequest 、Fetch等方式传输数据（**发送AJAX请求**）
* **允许**
  * **跨域写操作**，例如链接（links），重定向以及表单提交
  * **跨域资源嵌入（第三方资源）**，如 script 标签嵌入脚本、link标签嵌入CSS、img嵌入图片等、iframe
    * **XSS攻击**警告！！！！浏览器是无法区分被插入的文件是恶意的还是正常的



## 跨域及其表现

**跨域请求**指的是：**受浏览器同源策略限制**的请求场景。也就是说，**不满足同源策略**，我们就说是跨域的。

**跨域的表现**：Ajax 请求发出去了，服务器也成功响应了，但是前端就是拿不到这个响应。

**本质上**：跨域请求的响应已经成功到达客户端，但是被**浏览器拦截**了

---

> 跨域请求可能会被黑客用来发动 **CSRF攻击**，也就是**跨站请求伪造**。



## 跨域表现原理、浏览器如何拦截响应

**发送请求：渲染进程 => 浏览器主进程 => 网络进程**

**返回响应：网络进程 => 浏览器主进程（检查是否跨域） => 渲染进程**

---

1. 浏览器是**多进程**的，**WebKit 渲染引擎**和**V8 引擎**都在**渲染进程**中。
2. 调用`xhr.send`、**准备发送Ajax 请求**，这些都是**渲染进程**中的处理，而每个渲染进程都在**安全沙箱**中运行（**站点隔离**：为不同的站点分配了沙箱，互不干扰）
3. **在沙箱中运行的渲染进程无法发送网络请求的**，必须通过**进程间通信**，将对应数据传递给**浏览器主进程**；**主进程**接收到后，交给**网络进程**来**真正地发出相应的网络请求**。
4. 在**服务端处理完数据后**，将**响应返回给主进程检查**
5. **拦截数据：**主进程发现是**跨域**请求，并且**没有CORS响应头**，**将响应体拦截**，不会发送给渲染进程。



## 为什么前后端分离下会出现跨域问题

前后端分离架构下，前端项目与后端项目是两个项目，独立部署在**两个不同的服务器**。

**浏览器**拿到**静态资源**后开始加载渲染，**通过ajax去向后端服务器请求资源**（同源限制），这就出现跨域问题。

> 如果是服务端渲染，数据请求都在服务器中完成，同源策略是浏览器的安全策略，故后端数据交互不受限



## 跨域解决方案

* **JSONP跨域**：利用浏览器同源策略**允许跨域嵌入**的特点，**script标签的src属性没有同源限制**
* **跨域资源共享 CORS**：浏览器提供的**官方跨域解决方案**，**允许浏览器向跨源服务器发出请求**
* **nginx反向代理跨域**：同源策略是浏览器的安全策略，不是HTTP协议上的限制
* **nodeJS中间件代理跨域**：同上，配置代理服务器实现数据转发
* **跨文档消息机制**：通过 **window.postMessage** 的 **JavaScript 接口**来**和不同源的 DOM** 进行通信
* document.domain() + iframe --- 来允许子域访问父域
* websocket协议跨域



### JSONP跨域

* **原理：**利用**<script>标签中src属性没有同源限制**（支持跨域）的特点，让服务器端返回可执行的Javascript代码来调用前端设置好的**回调函数**并**传入数据**

* **步骤：**
  1. **前端定义回调函数**，放入数据处理逻辑（拿到数据后就会回调此函数）
  2. 在API接口后面**拼接上回调函数的名字**并发送给服务端
  3. 服务端拿到url传递的参数后，会针对query参数（回调函数名），**返回一个/多个函数调用表达式（可执行代码）**，并传入需要传递的JSON数据
  4. script标签指向的资源文件被下载后，其中的Javascript代码会被**立即执行**，也就实现了跨域请求

* **缺点**：只能实现**get请求**； **代码注入**，安全隐患； **错误处理机制不够完善**
* **优点**：兼容性好，可兼容低版本IE


```js
// 前端代码
const jsonp = ({ url, params, callbackName }) => {
  const generateURL = () => {
    let dataStr = '';
    for(let key in params) {
      dataStr += `${key}=${params[key]}&`;
    }
    dataStr += `callback=${callbackName}`;
    return `${url}?${dataStr}`;
  };
  return new Promise((resolve, reject) => {
    // 初始化回调函数名称
    callbackName = callbackName || Math.random().toString.replace(',', ''); 
    // 创建 script 元素并加入到当前文档中
    let scriptEle = document.createElement('script');
    scriptEle.src = generateURL();
    document.body.appendChild(scriptEle);
    // 绑定到 window 上，为了后面调用
    window[callbackName] = (data) => {
      resolve(data);
      // script 执行完了，成为无用元素，需要清除
      document.body.removeChild(scriptEle);
    }
  });
}

jsonp({
  url: 'http://localhost:3000',
  params: { 
    a: 1,
    b: 2
  }
}).then(data => {
  // 拿到数据进行处理
  console.log(data); // 数据包
})
```

```js
// 服务端代码
let express = require('express')
let app = express()
app.get('/', function(req, res) {
  let { a, b, callback } = req.query
  console.log(a); // 1
  console.log(b); // 2
  // 注意哦，返回给script标签，浏览器直接把这部分字符串执行
  res.end(`${callback}('数据包')`);
})
app.listen(3000)
```



### CORS相关

#### CORS简介

CORS 是一种**官方跨域方案**：允许浏览器向**跨源服务器**发出请求，克服了AJAX只能同源使用的限制

* 只要服务器实现了**CORS接口**，**设置对应的响应头**，就可以跨源通信；
* 由**浏览器**自动执行CORS通信过程，无需用户操作（浏览器检查，决定是否拦截）



#### 如何实现CORS / CORS响应头

* **Access-Control-Allow-Origin**：指定允许哪个请求域响应数据，决定浏览器是否拦截响应（*表示任意）
* **Access-Control-Allow-Methods**：指定请求域能够使用的请求方法

> **其他头部**
>
> * **Access-Control-Allow-Credentials：**（**预检请求**响应的一部分）表示是否允许浏览器在真实请求中携带发送 Cookie
>
>   * 跨域默认false，**如果要拿到Cookie的话**，将该字段设置为true，并且需要设置**`withCredentials`属性**
>
> * **Access-Control-Request-Headers**： **预检请求**中，用于通知服务器在真正请求中会采用哪些请求头。
> * **Access-Control-Max-Age**: 预检请求的有效期，在此期间，不用发出另外一条预检请求。



#### CORS下的两种请求

**两种请求：**使用CORS时，跨域请求会被分为**简单请求和非简单请求**

* **简单请求：**
  * 请求方法为 **GET、 HEAD、POST**
  * 头部字段满足规范定义的 **对CORS安全的首部字段集合**
  * **ContentType的值**仅限于下列三者之一：
    - text/plain
    - multipart/form-data
    - application/x-www-form-urlencoded
  * 请求中的**XMLHttpRequestUpload 对象**均没有注册事件监听器
  * 请求中没有使用 **ReadableStream 对象**
* **非简单请求**：除了简单请求之外的请求



#### 简单请求处理过程

* **请求发出前**：**浏览器**自动在请求头当中，添加一个**`Origin`字段**，用来说明请求来自哪个源
* **服务器拿到请求之后**：服务器在响应头上添加**`Access-Control-Allow-Origin`字段**（还有其他相关字段）
* **浏览器拿到响应后**：由浏览器判断**`Origin`字段**是否在**`Access-Control-Allow-Origin`字段**的范围中，如果不是，浏览器会拦截该响应



#### 非简单请求处理过程

> 非简单请求处理过程的特点：**预检请求**、**响应字段**

* 发送非简单请求时，**浏览器**会**自动**先发送**预检请求（OPTIONS请求）**，用于获知服务器是否接受该请求
* 服务器**返回预检请求的响应**，包括服务器的一些**跨域限制字段**
* **浏览器检查响应**：如果真实请求**不满足响应头的限制**，触发`XMLHttpRequest`的**`onerror`方法**，**不发送**真正的CORS请求。
* **简单请求流程**【给真实请求自动添加Origin字段、服务器添加字段、浏览器检验字段】

---

**预检请求**

* 预检请求OPTIONS中包括**`Origin`源地址和`Host`目标地址**，以及两个关键字段：
  * Access-Control-Request-Method：真实请求的HTTP方法
  * Access-Control-Request-Headers：真实请求中携带的请求头

* 作用：用于获知服务器是否接受该请求，**避免跨域请求对服务器的用户数据产生未预期的影响**【服务器返回响应，浏览器检查】

**响应字段**

* 一部分是对于**预检请求**的响应，一部分是对于 **CORS 请求**的响应
* **对预检请求的响应**可能包括以下字段 Access-Control-Allow-Origin/Methods/Credentials/Header/Max-Age





### nginx 反向代理跨域

**原理：** **同源策略是浏览器的安全策略，不是HTTP协议的一部分**。在服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不受同源限制，也就不存在跨越问题**（开发阶段用本地代理）**

**实现思路：**

* 通过nginx（反向代理服务器）**配置一个代理服务器（域名与客户端相同）做跳板**
* 当A网站向B网站发送请求时，nginx**根据配置文件接收这个请求**，**代替A网站向B网站来请求**。
* nginx拿到这个资源后再返回给A网站，以此来解决了跨域问题。



### Nodejs中间件代理跨域

原理大致域nginx相同，通过开启一个**代理服务器**来实现**数据转发**



### postMessage【HTML5】

- targetWindow.postMessage(message,targetOrigin) 是html5新引进的特性
- **可以使用postMessage来向其它的window对象发送消息，不受同源限制**
- window.postMessage() 方法被调用时，会**在所有页面脚本执行完毕之后**，向目标窗口派发一个  **MessageEvent 消息。**目标窗口监听message事件，获取相关信息后也可以先判断是否为目标域，再获取数据进行操作（安不安全是可控的）。




### document.domain() + iframe

document.domain() 可以用于**获取当前文档的域名 | 重新设置其值为当前域的父域（基础域名）**，也就是强制进行域名转换来实现同源。

**document.domain() 实现跨域的前提条件：**

* 这**两个域名必须属于同一个基础域名**（存在父子关系），而且所用的协议、端口相同。
* 父域也需要重新设置document.domain（即使值不变），以确保端口号相同
  * 因为任何对document.domain的赋值操作都会导致端口号被重写为 `null` 



### WebSocket协议跨域

WebSocket允许跨域的全双工通信



## JSONP和CORS的优缺点比较

**JSONP**

* 优点：兼容性好 ---- 因为script 本身就隶属于 HTML 的标签
* 缺点：
  * 仅支持 **get 请求** --- 使用 URL 引入资源
  * script 标签会将资源作为 JS 代码执行，所以可能会被**注入恶意代码** 
  * **错误处理机制**不够完善

**CORS**

* 优点：

  * 使用**简单**方便、更为**安全**
  * 支持**多种HTTP请求**方式
  * 可以通过**onerror事件监听错误**，并且浏览器控制台会看到报错信息，利于排查。

* 缺点：存在兼容问题——仅支持 IE10 以上

  

## JSONP和CORS的应用场景区别

如果需要考虑**兼容性**：JSONP

如果需要发出**多种类型**的HTTP请求：CORS



## script、img、link标签为何不受同源限制

同源策略中允许跨域嵌入、跨域写，而限制跨域读操作，script、img、link标签都是跨域嵌入



## 跨域请求中，需要设置哪个属性为true,才能携带cookie信息？

在发送XMLHttpRequest**跨域请求**之前：

* 需要设置 **withCredentials** 为true（默认为false），否则**不能携带cookie信息**。

* 设置withCredentials 为true后携带的 cookies也会受**同源策略**限制，不能被document.cookie 或 从头部相应请求的脚本等访问，所以也需要设置 **Access-Control-Allow-Credential**













# Web安全相关

## XSS

### XSS简介

**XSS**（**跨站脚本攻击**）：**利用站点漏洞在Web页面（HTML 文件｜ DOM ）里注入恶意代码**，窃取用户信息

当用户浏览网页时，嵌入Web里面的恶意代码会**被执行**，从而对用户实施攻击。

> 浏览器的**同源策略**里面**允许嵌入不同源的第三方资源**，也间接造成了XSS相关安全问题，因为**浏览器无法区分被插入的文件是恶意的还是正常的**~



### XSS会造成的危害

* **窃取 Cookie 信息**，将用户的Cookie信息**通过 XMLHttpRequest 或者 Fetch（+ CORS）**发送给黑客的服务器，在其他电脑上模拟用户登录
  * 恶意注入的 JavaScript 脚本拥有所有的脚本权限：**通过“document.cookie”获取 Cookie**
* **监听用户行为**：使用“addEventListener”接口来监听键盘事件（输入密码等）
* 通过**修改 DOM** 伪造假的登录窗口，用于盗取用户输入用户名和密码等信息
* **在页面内生成浮窗广告**，这些广告会**严重地影响用户体验**



### XSS的类型

XSS攻击根据效果的不同可以分为三类：**存储型，反射型 和基于 DOM 型 **。

* **存储型（持久型）**
  * **存储型 XSS** 会**把恶意代码 "存储" 到存在漏洞的服务器端**【稳定性强】
  * 当（其他）浏览器**访问对应页面**时，恶意代码就会包含在服务器**响应数据**中**返回并执行**，实施攻击
  * **常见场景**：社区或论坛的留言板
* **反射型（非持久型）**
  * **恶意脚本属于用户发送给网站请求中的一部分**，随后网站又把**恶意 JavaScript 脚本**返回给用户
    * 搜索框中的内容会**作为参数拼接到URL中**发送给服务器，一旦在参数中加入一些**浏览器中的可执行脚本**，服务器返回对应的页面/数据，恶意脚本会执行，也就形成了**反射型XSS**
  * 黑客通常会分析被攻击的网站，找到这样的漏洞，**构造恶意链接**，**比如在参数中加入 < script > 标签引用恶意脚本**，通过 QQ 群或者邮件等渠道**诱导用户点击**恶意链接
* **基于 DOM** 
  * 指**通过恶意脚本修改当前 Web 页面中的数据**（伪造登录窗口）

---

> 反射型XSS、存储型XSS 需要**在服务端拼接用户输入作为HTML输出到页面** => **服务端的安全漏洞**
>
> 基于 DOM型XSS是纯粹发生在**客户端**的攻击，利用**浏览器解析机制**导致的漏洞 => **前端的安全漏洞**



### 如何防范XSS攻击

> 思路：阻止**恶意脚本的注入** | 阻止**恶意消息的发送**（窃取cookie）

* **服务器对用户输入进行过滤或转码（关键字符）** 【**客户端的输入检查容易被绕过**】
  * **富文本**：引入白名单，允许 < a>、< div>、< img> 等较安全的标签，而限制比较危险的 < iframe>、< script>、< form> 等标签
* **服务器的输出检查**：同上过滤与转码
* **使用 Cookie 的 HttpOnly属性**，防止 XSS 攻击后Cookie被挟持
  * 服务器通过 **HTTP 响应头设置HttpOnly**，而页面内的Javascript无法访问带有HttpOnly属性的cookie
* **充分利用 CSP** 能够有效降低 XSS 攻击的概率（也有不好的地方嗷~）
* **添加验证码**，防止脚本冒充用户提交危险操作（危险操作时验证用户，但是反复验证可能会有用户体验的问题）
* 对于一些不受信任的输入，可以**限制其输入长度**

----

> #### CSP 内容安全机制
>
> * CSP以**白名单**的机制对网站加载或执行的资源起作用，**通过 HTTP 头信息或者 meta 元素定义**。
>   * **核心思想**是让**服务器决定**浏览器能够加载哪些资源，能否执行内联 JavaScript 代码
>
> * **造成的问题：**Eval及相关函数被禁用、内嵌的JavaScript代码将不会执行、只能通过白名单来加载远程脚本。
>   * 如果想使用CSP技术保护自己的网站，开发者需要花费大量时间分离内嵌的JavaScript代码和做一些调整
>
> ---
>
> CSP的功能如下
>
> * 可限制加载其他域下的资源文件 => 即使黑客插入了一个 JavaScript 文件也无法被加载
> * 禁止向第三方域提交数据 => 用户数据也不会外泄
> * 禁止执行内联脚本和未授权的脚本
> * 提供了上报机制 => 可以帮助开发者尽快发现有哪些 XSS 攻击，以便尽快修复问题。

---



## CSRF

### CSRF简介

CSRF（即**跨站请求伪造**）：**利用用户的登录状态，通过第三方站点来向服务器发送非预期请求**

---

**发起CSRF攻击的必要条件：**

1. 目标站点有 CSRF 漏洞
2. 用户登录过目标站点
3. 用户打开第三方站点，可以是黑客的站点，也可以是一些论坛
4. 隐性前提（本质）：攻击者可以猜到重要操作的所有参数，进而可以**伪造用户请求**



### CSRF 攻击思想

1. 用户**登录了网站A**；验证通过，网站A的服务器**返回用户的登录状态**，如：Cookie、Session等**存放在客户端**
2. 用户没有退出A网站的登录状态（有些Cookie是持久型的），并且**访问了危险网站B**【黑客引诱点开连接】
3. **危险网站B**中发出一个请求，要求**访问网站A**，浏览器会**携带**网站A存在客户端中的cookie去**发送请求**
4. 由于请求中携带Cookie，网站A的服务端会**以用户权限来处理危险网站的请求**，这也就成功发动了CSRF攻击

----

> 当用户打开了黑客的页面后，黑客有三种方式去实施 CSRF 攻击
>
> * **伪造 Get 请求**：将A站点的转账请求**隐藏在 img 标签之中**，页面加载时会**自动发送Get请求**
>
> * **伪造 POST 请求：**构建隐藏表单，打开页面时**自动执行**对应的脚本语句去**提交表单**，**发送POST请求**
>
>   ```html
>   <body>
>     <h1>黑客的站点：CSRF攻击演示</h1>
>     <form id='hacker-form' action="https://time.geekbang.org/sendcoin" method=POST>
>       <input type="hidden" name="user" value="hacker" />
>       <input type="hidden" name="number" value="100" />
>     </form>
>     <script> document.getElementById('hacker-form').submit(); </script>
>   </body>
>   ```
>
> * **引诱用户点击链接**
>
>   ```html
>   <div>
>     <img width=150 src=http://images.xuejuzi.cn/1612/1_161230185104_1.jpg> </img> </div> <div>
>     <a href="https://time.geekbang.org/sendcoin?user=hacker&number=100" taget="_blank">
>       点击下载美女照片
>     </a>
>   </div>
>   ```

---

---

> * 浏览器自动携带该站点的cookie发送请求，是Cookie的特性，与是否跨域无关
>   * **实际上并不能拿到 Cookie**，也无法读取内容。【新增的Samesite属性！禁止携带**第三方Cookie**】
> * **服务端可以设置`Access-Control-Allow-Origin`**来限制请求域，浏览器主进程会**判断请求域是否被允许**，来决定是否拦截响应【拦截 === 不让Javascript脚本获取，但仍然能在NetWork中看到返回】
> * 对于服务器返回的结果，由于**浏览器同源策略**的限制，攻击者也**无法进行解析**。因此，攻击者无法从返回的结果中得到任何东西，他所能做的就是**给服务器发送请求**，以执行请求中所描述的命令，**在服务器端直接改变数据的值**，而非窃取服务器中的数据【所以对于 CSRF 攻击我们主要的防护手段是**提升服务器的安全性**】



### 如何防范CSRF 攻击

* **设置 Cookie 的 SameSite 属性**：禁止浏览器在第三方站点的请求中携带某些关键 Cookie 数据到服务器

* **验证请求的来源站点**：在**服务端**验证请求来源的站点，禁止来自第三方站点的请求**【优先检查Origin字段，没有则检查Reffer】**

  * **Referer字段（不可靠）**：记录了该HTTP请求的**来源地址**（URL），但不是所有请求中都包含Referer字段
  * **Origin字段**：**Post请求中**，Origin记录了该HTTP请求的**域名信息，不包含路径**（不涉及隐私问题）；但Get请求中无Origin

* **CSRF Token**：核心思想是在请求中要求放入**攻击者不能伪造（猜测）的信息**

  * 身份验证时，服务端生成并返回一个CSRF Token；如果浏览器要执行转账之类的请求，则需要带上Token，**服务端设置拦截器验证Token**。而第三方站点发出的请求无法获取该Token（不存在于Cookie中）

* **验证码**：CSRF 的攻击过程往往是在**用户不知情**的情况下构造网络请求，而验证码则**强制用户与应用发生交互**，才能完成最终请求

  * 防御，最**简洁有效**，但是**破坏了用户体验**

* **响应头部 X-XSS-Protection：**检查到XSS攻击时，停止渲染页面（IE8中检查到攻击时，整个页面会被一个#替换）


```html
    <form action="https://time.geekbang.org/sendcoin" method="POST">
      <input type="hidden" name="csrf-token" value="nc98P987bcpncYhoadjoiydc9ajDlcn">
      <input type="text" name="user">
      <input type="submit">
    </form>
```



## 头部安全相关字段

- **Cookie的Secure字段**

- **Cookie的SameSite字段**：CSRF

- **Cookie的HttpOnly字段**：XSS

- **响应头部 X-Frame-Options**：表明是否可以加载、嵌入一个iframe页面（完全不能|能嵌入同源|指定）

  > **点击挟持**：攻击者设置一个**透明的**iframe覆盖在网页上，诱使用户在iframe网页上进行操作（点击一些危险的功能性按钮）

- **响应头部 X-Content-Type-Options：** **禁止浏览器开启MIME嗅探**猜测资源类型（可能会使不可执行的MIME变为可执行的MIME类型）

  > 某些浏览器会启用**MIME嗅探**来猜测该资源的类型（Content-Type错误或未定义），解析内容并执行。

- **响应头部 X-XSS-Protection：**检查到XSS攻击时，停止渲染页面（IE8中检查到攻击时，整个页面会被一个#替换）

