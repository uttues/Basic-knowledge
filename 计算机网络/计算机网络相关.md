## HTTP协议的发展历程

### 超文本传输协议 HTTP/0.9

**需求**：在网络之间传递 HTML 超文本的内容（超文本传输协议）

**特点**：

* 客户端发送请求时只有一个请求行，无请求头、请求体
* 服务器不返回头信息（直接返回数据）
* 返回的文件内容是以 **ASCII 字符流**来传输的（都是 HTML 格式的文件）

![img](https://static001.geekbang.org/resource/image/db/34/db1166c68c22a45c9858e88a234f1a34.png)



### 被浏览器推动的 HTTP/1.0

**核心诉求**：支持**多种类型的文件下载**

> 在浏览器中展示的不单是 HTML 文件，还包括 JavaScript、CSS、图片、音频、视频等不同类型的文件
>
> 1. 浏览器需要知道服务器返回数据的数据类型、压缩方法、语言版本、编码类型

**特点**：

* 引入了**请求头和响应头**，以 Key-Value 形式保存，支持多类型文件传输、多编码等
  * 在请求头中还加入了**用户代理**的字段（服务器需要统计客户端基础信息）
* 引入了**状态码**，表明服务器最终处理该请求的情况
* 提供了 **Cache 机制**，用来缓存已经下载过的数据

![img](https://static001.geekbang.org/resource/image/b5/7d/b52b0d1a26ff2b8607c08e5c50ae687d.png)

```js
// 请求头（表明浏览器的期待，但服务端仍可以指定）
accept: text/html
accept-encoding: gzip, deflate, br
accept-Charset: ISO-8859-1,utf-8
accept-language: zh-CN,zh
// 状态码
content-encoding: br
content-type: text/html; charset=UTF-8
```

### 缝缝补补的 HTTP/1.1

#### HTTP/1.1 的改进

**长连接|持久连接** 

* **问题：**HTTP1.0 每次通信都需要经历**建立 TCP 连接、传输 HTTP 数据和断开 TCP 连接**，开销大
  * 页面更复杂了，需要引用的资源更多，开销大
* **表现：**在一个 TCP 上可以传输多个 HTTP 请求，只要浏览器或服务器不明确断开，TCP链接就会一直保持
  * **默认开启**，请求头上加入Connection: close可关闭长连接

**并发连接**

* **表现：**允许一个域名分配多个长连接（TCP），一个队列阻塞，其他队列还可继续（Chrome默认6个）

**域名分片**

* **表现**：引入CDN，一个域名下分出多个**二级域名**（一个域名6个长链接），指向同一台服务器【过时了！】

**不成熟的 HTTP 管线化（最终被浏览器厂商放弃）**

* **问题**：在长连接上依然存在**队头阻塞**问题
* **表现**：将**多个 HTTP 请求整批提交给服务器**【整批发送请求，但服务器依然需要根据请求顺序来返回响应】
* FireFox、Chrome 都做过管线化的试验，但是由于各种原因，它们最终都放弃了管线化技术。

**提供虚拟主机的支持 Host字段**

* 在 HTTP/1.0 中，**每个域名绑定了一个唯一的 IP 地址**，一个服务器只能支持一个域名
* 随着虚拟主机技术的发展，需要实现**在一台物理主机上绑定多个虚拟主机**（单独的域名，公用的 IP 地址）
* **表现**：在 HTTP/1.1 请求头新增 **Host 字段**，表示**当前域名地址**，这样服务器就可以根据不同的 Host 值做不同的处理

**引入 Chunk transfer 机制支持动态生成的内容**

* **问题**：HTTP/1.0 时，需要在响应头中设置**完整的数据大小**Content-Length（动态内容在**传输前难确定**），导致**浏览器不知道何时会接收完所有的文件数据**
* **表现**：服务器会**将数据分割成若干个任意大小的数据块**，每个数据块发送时会附上上各数据块的长度，最后使用一个零长度的块作为发送数据完成的标志

**客户端 Cookie机制**

**安全机制**



#### HTTP/1.1 存在问题：带宽利用率低

原因

* **TCP 的慢启动**：传输速度**先（非常）慢后快**【 TCP 为了减少网络拥塞的一种策略（但在并发连接下导致数据传输更慢了）】
* **多条TCP连接竞争固定的带宽**：带宽充足时，传输速度会慢慢增加；带宽不足时，这些 **TCP 连接就需要动态减慢接收数据的速度**（可能是关键资源）
* **队头阻塞**：一个TCP被多个HTTP请求复用（长连接）

---

> **带宽**是指每秒最大能发送或者接收的字节数
>
> * 上行带宽：每秒能发送的最大字节数
> * 下行带宽：每秒能接收的最大字节数



### HTTP/2

思路：**一个域名只使用一个 TCP 长连接（一次慢启动，不竞争带宽）和消除队头阻塞问题**

#### 多路复用（核心特性）

**作用**：充分利用带宽，最大限度规避了 TCP 的慢启动所带来的问题

**实现原理：**通过**引入二进制分帧层将请求分成一帧一帧的数据去传输**，来实现 HTTP 的多路复用技术，实现资源的**【并行传输】**

* 客户端请求**经过二进制分帧层处理**后，会被转换为一个个**带有请求 ID 编号的数据帧**，通过协议栈将这些帧发送给服务器【每个请求都有一个对应的 ID】
* 服务器接**收到所有帧**之后，会将所有**相同 ID 的帧合并为一条完整的请求信息**，并**处理该请求** **【可以优先处理关键资源的请求，优先级高】**
* 服务器**将处理后的响应行、响应头和响应体分别发送至二进制分帧层**，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。
* 浏览器接收到返回的**响应帧**之后，会**根据 ID 编号将帧的数据**返回给对应的请求。

![image-20200720184848771](C:\Users\GZS15720\AppData\Roaming\Typora\typora-user-images\image-20200720184848771.png)



#### 其他特性

* **可以设置请求的优先级**（关键资源）
* **服务器推送**：HTTP/2 可以直接**将数据推送到浏览器**（如果服务器知道该 HTML 页面会引用哪些关键资源，就可以在 HTML 请求之后，将关键资源一并发送）

* **头部压缩**：减少传输数据的大小



#### HTTP/2 存在问题

**TCP队头阻塞**

- 在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果**其中任意一路数据流中出现了丢包**的情况，那么就会**阻塞该 TCP 连接中的所有请求**。
- 随着**丢包率的增加**，HTTP/2 的**传输效率也会越来越差**

**TCP 建立连接会产生网络延时**

* 建立TCP连接，需要进行三次握手（消耗 1.5 个 RTT ）
* 进行 TLS 连接也需要经过一次握手过程（大致是消耗 1～2 个 RTT ）需要 1～2 个 RTT

---

> 网络延迟又称为 RTT（Round Trip Time）：从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间（反映网络性能的一个重要指标）

**TCP 协议僵化：很难改进**

* 中间设备的僵化（物理设备）
* 操作系统的僵化（通常操作系统的更新都滞后于软件的更新）



### HTTP/3

**QUIC 协议：**基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能 【中间设备僵化：只认TCP、UDP】

![image-20200720191556609](C:\Users\GZS15720\AppData\Roaming\Typora\typora-user-images\image-20200720191556609.png)

#### QUIC 协议的功能

* 实现了类似 TCP 的**流量控制、拥塞控制、可靠传输、数据包重传等**的功能。

* 集成了 **TLS 加密功能**。相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。

* **多路复用**功能。**和 TCP 的思路不同**，QUIC 实现了**在同一物理连接上可以有多个独立的逻辑数据流**（数据流的单独传输）

* **快速握手**：QUIC 是**基于 UDP** 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接

  ![image-20200720191850884](C:\Users\GZS15720\AppData\Roaming\Typora\typora-user-images\image-20200720191850884.png)

#### HTTP/3 的挑战

* 服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持
* 部署 HTTP/3 存在着非常大的问题（系统内核对UDP的优化不足）
* 中间设备僵化。中间设备对 UDP 的优化程度远远低于 TCP



## 队头阻塞

#### HTTP1.1 队头阻塞

* **表现**：必须 **等待请求完成后才能去请求下一个资源**（串行）

* **原因**：HTTP 传输是**基于请求-应答的模式**进行的，**一发一收**（请求在任务队列中**串行执行**会发生阻塞）
* **解决路径**
  * HTTP/1.1 **管线化技术**、**并发连接**、**域名分片** 
  * HTTP 2 **多路复用**【TCP 队头阻塞】

#### TCP 队头阻塞

**原因：**TCP连接传输数据中由于单个数据包的丢失而造成的阻塞

**TCP正常传输过程**：发送端的数据会被**拆分**为**有序的**小数据包，这些小数据包通过网络传输到了接收端，会**按序组合**成原始数据

![image-20200720185508050](C:\Users\GZS15720\AppData\Roaming\Typora\typora-user-images\image-20200720185508050.png)

**异常**：如果出现**数据丢包**，那么**整个 TCP 连接就会处于暂停状态**，需要**等待**丢失的数据包被重新传输过来。

![image-20200720185818531](C:\Users\GZS15720\AppData\Roaming\Typora\typora-user-images\image-20200720185818531.png)





















## 浏览器的安全策略

**同源策略**（最基础、最核心）：浏览器使用同源策略来**控制不同源之间的交互**【**并不是拒绝所有的跨域请求**】

**内容安全策略CSP**：**核心思想**是让**服务器决定**浏览器能够加载哪些资源，能否执行内联 JavaScript 代码

* 对第三方资源作出限制

**跨域资源共享 CORS**：可以进行**跨域访问控制**，从而使跨域数据传输得以安全进行

**跨文档消息机制**：可以通过 **window.postMessage** 的 **JavaScript 接口**来**和不同源的 DOM** 进行通信





# 同源策略与跨域相关

## 同源策略

**同源：** **协议、端口、域名**相同，则这两个URL同源

**同源策略：**浏览器使用同源策略来**控制不同源之间的交互**（**并不是拒绝所有的跨域请求**）

* **限制（跨域读操作）**
  * DOM：禁止来自不同源的 JavaScript 脚本**对DOM 对象读和写** | **获取Javascript对象**
  * 数据：限制了不同源的站点**读取 Cookie、IndexDB、LocalStorage** 等数据
  * 网络：限制了不同源的站点之间通过 XMLHttpRequest 、Fetch等方式传输数据（**发送AJAX请求**）
* **允许**
  * **跨域写操作**，例如链接（links），重定向以及表单提交
  * **跨域资源嵌入（第三方资源）**，如 script 标签嵌入脚本、link标签嵌入CSS、img嵌入图片等、iframe
    * **XSS攻击**警告！！！！浏览器是无法区分被插入的文件是恶意的还是正常的



## 跨域及其表现

**跨域请求**指的是：**受浏览器同源策略限制**的请求场景。也就是说，**不满足同源策略**，我们就说是跨域的。

**跨域的表现**：Ajax 请求发出去了，服务器也成功响应了，但是前端就是拿不到这个响应。

**本质上**：跨域请求的响应已经成功到达客户端，但是被**浏览器拦截**了

---

> 跨域请求可能会被黑客用来发动 **CSRF攻击**，也就是**跨站请求伪造**。



## 跨域表现原理、浏览器如何拦截响应

**发送请求：渲染进程 => 浏览器主进程 => 网络进程**

**返回响应：网络进程 => 浏览器主进程 => 渲染进程**

---

1. 浏览器是**多进程**的，**WebKit 渲染引擎**和**V8 引擎**都在**渲染进程**中。
2. 调用`xhr.send`、**准备发送Ajax 请求**，这些都是**渲染进程**中的处理，而每个渲染进程都在**安全沙箱**中运行（站点隔离：为不同的站点分配了沙箱，互不干扰）
3. **在沙箱中运行的渲染进程无法发送网络请求的**，必须通过**进程间通信**，将对应数据传递给**浏览器主进程**；**主进程**接收到后，交给**网络进程**来**真正地发出相应的网络请求**。
4. 在**服务端处理完数据后**，将**响应返回给主进程检查**
5. **拦截数据：**主进程发现是**跨域**请求，并且**没有CORS响应头**，**将响应体拦截**，不会发送给渲染进程。



## 为什么前后端分离下会出

前后端分离架构下，前端项目与后端项目是两个项目，独立部署在**两个不同的服务器**。

**浏览器**拿到**静态资源**后开始加载渲染，**通过ajax去向后端服务器请求资源**（同源限制），这就出现跨域问题。

> 如果是服务端渲染，数据请求都在服务器中完成，同源策略是浏览器的安全策略，故后端数据交互不受限



## 跨域解决方案

* **JSONP跨域（JSON+Padding）**
* **跨域资源共享 CORS**：使用 CORS 可以进行跨域访问控制，从而使跨域数据传输得以安全进行
* **nginx反向代理跨域（开发阶段用本地代理）**
* **跨文档消息机制**：通过 **window.postMessage** 的 **JavaScript 接口**来**和不同源的 DOM** 进行通信
* nodeJS代理跨域
* document.domain() + iframe --- 来允许子域访问父域
* websocket协议跨域



### CORS相关

#### CORS简介

 "跨域资源共享"是一种**官方跨域方案**，CORS **允许浏览器向跨源服务器发出请求**，从而克服了AJAX只能同源使用的限制。【需要浏览器和服务器的共同支持】

* 只要服务器实现了**CORS接口**（设置对应的响应头），就可以跨源通信；
* 由**浏览器**自动执行CORS通信过程，无需用户操作。



#### 如何实现CORS / CORS响应头

服务端通过设置**响应头**实现，**让服务器声明允许的访问来源**

* **Access-Control-Allow-Origin**：设置允许哪个请求域响应数据，决定浏览器是否拦截响应
  * 填`*`表示允许任意源请求
* **Access-Control-Allow-Methods**：指定请求域能够使用的请求方法

> **其他头部**
>
> * **Access-Control-Allow-Credentials：**（预检请求响应的一部分）表示是否允许浏览器在真实请求中携带发送 Cookie
>
> * 跨域默认false，如果要拿到Cookie的话，将该字段设置为true，并且设置`withCredentials`属性
>
> * **Access-Control-Request-Headers**： 预检请求中，用于通知服务器在真正请求中会采用哪些请求头。
> * **Access-Control-Max-Age**: 预检请求的有效期，在此期间，不用发出另外一条预检请求。



#### CORS下的两种请求

**两种请求：**使用CORS时，跨域请求会被分为**简单请求和非简单请求**

* **简单请求：**
  * 请求方法为 **GET、 HEAD、POST**
  * 头部字段满足规范定义的 **对CORS安全的首部字段集合**
  * **ContentType的值**仅限于下列三者之一：
    - text/plain
    - multipart/form-data
    - application/x-www-form-urlencoded
  * 请求中的**XMLHttpRequestUpload 对象**均没有注册事件监听器
  * 请求中没有使用 **ReadableStream 对象**
* **非简单请求**：除了简单请求之外的请求



#### 简单请求处理过程

* **请求发出前**：**浏览器**自动在请求头当中，添加一个**`Origin`字段**，用来说明请求来自哪个源
* **服务器拿到请求之后**：服务器在响应头上添加**`Access-Control-Allow-Origin`字段**（还有其他相关字段）
* **浏览器拿到响应后**：由浏览器判断**`Origin`字段**是否在**`Access-Control-Allow-Origin`字段**的范围中，如果不是，浏览器会拦截该响应



#### 非简单请求处理过程

> 非简单请求处理过程的特点：**预检请求**、**响应字段**

* 发送非简单请求时，**浏览器**会**自动**先发送**预检请求（OPTIONS请求）**，用于获知服务器是否接受该请求
* 服务器**返回预检请求的响应**，包括服务器的一些**跨域限制字段**
* **浏览器检验**
  * 如果真实请求**不满足响应头的限制**，触发`XMLHttpRequest`的**`onerror`方法**，**不发送**真正的CORS请求。
  * 否则发送真正的CORS请求
* **简单请求流程**【给真实请求自动添加Origin字段、服务器添加字段、浏览器检验字段】

---

**预检请求**

* 预检请求OPTIONS中包括**`Origin`源地址和`Host`目标地址**，以及两个关键字段：
  * Access-Control-Request-Method：真实请求的HTTP方法
  * Access-Control-Request-Headers：真实请求中携带的请求头

* 作用：用于获知服务器是否接受该请求，**避免跨域请求对服务器的用户数据产生未预期的影响**

**响应字段**

* 一部分是对于**预检请求**的响应，一部分是对于 **CORS 请求**的响应
* **对预检请求的响应**可能包括以下字段 Access-Control-Allow-Origin/Methods/Credentials/Header/Max-Age



### JSONP跨域

* **原理：**利用**<script>标签中src属性没有同源限制**（支持跨域）的特点，让服务器端返回可执行的Javascript代码，并在这个Javascript代码中调用前端设定好的回调函数并将需要传输的数据放入回调函数的参数中。

* **步骤：**
  1. 前端定义回调函数，放入数据处理逻辑（拿到数据后就会回调此函数）
  2. 在API接口后面拼接上回调函数的名字并发送给服务端
  3. 服务端拿到url传递的参数后，会针对这些参数，也就是回调函数名返回一个/多个函数调用表达式，并将需要传递的JSON数据放入（填充进）回调参数里
  4. script标签指向的资源文件被下载后，其中的Javascript代码会被**立即执行**，也就实现了跨域请求

* **优缺点：**
  * 缺点：只能实现get请求、代码注入，安全隐患、错误处理机制不够完善
  * 优点：兼容性好，可兼容低版本IE


```js
// 前端代码
const jsonp = ({ url, params, callbackName }) => {
  const generateURL = () => {
    let dataStr = '';
    for(let key in params) {
      dataStr += `${key}=${params[key]}&`;
    }
    dataStr += `callback=${callbackName}`;
    return `${url}?${dataStr}`;
  };
  return new Promise((resolve, reject) => {
    // 初始化回调函数名称
    callbackName = callbackName || Math.random().toString.replace(',', ''); 
    // 创建 script 元素并加入到当前文档中
    let scriptEle = document.createElement('script');
    scriptEle.src = generateURL();
    document.body.appendChild(scriptEle);
    // 绑定到 window 上，为了后面调用
    window[callbackName] = (data) => {
      resolve(data);
      // script 执行完了，成为无用元素，需要清除
      document.body.removeChild(scriptEle);
    }
  });
}

jsonp({
  url: 'http://localhost:3000',
  params: { 
    a: 1,
    b: 2
  }
}).then(data => {
  // 拿到数据进行处理
  console.log(data); // 数据包
})
```

```js
// 服务端代码
let express = require('express')
let app = express()
app.get('/', function(req, res) {
  let { a, b, callback } = req.query
  console.log(a); // 1
  console.log(b); // 2
  // 注意哦，返回给script标签，浏览器直接把这部分字符串执行
  res.end(`${callback}('数据包')`);
})
app.listen(3000)
```



### nginx 反向代理跨域

**原理：** **同源策略是浏览器的安全策略，不是HTTP协议的一部分**。在服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不受同源限制，也就不存在跨越问题。

**实现思路：**

* 通过nginx（反向代理服务器）**配置一个代理服务器（域名与客户端相同）做跳板**
* 当A网站向B网站请求某个接口时，向B网站发送一个请求，nginx**根据配置文件接收这个请求**，代替A网站向B网站来请求。
* nginx拿到这个资源后再返回给A网站，以此来解决了跨域问题。



### Nodejs中间件代理跨域

原理大致域nginx相同，通过开启一个代理服务器来实现数据转发



### postMessage

targetWindow.postMessage(message,targetOrigin) 是html5新引进的特性，**可以使用postMessage来向其它的window对象发送消息，不受同源限制**

window.postMessage() 方法被调用时，会在所有页面脚本执行完毕之后,向目标窗口派发一个  **MessageEvent 消息。**目标窗口监听message事件，获取相关信息后也可以先判断是否为目标域，再获取数据进行操作（安不安全是可控的）。



### document.domain() + iframe

document.domain() 可以用于**获取当前文档的域名或者重新设置其值为当前域的父域（基础域名）**，也就是强制进行域名转换来实现同源。

**document.domain() 实现跨域的前提条件：**

* 这**两个域名必须属于同一个基础域名**（存在父子关系），而且所用的协议、端口相同。
* 父域也需要重新设置document.domain（即使值不变），以确保端口号相同
  * 因为任何对document.domain的赋值操作都会导致端口号被重写为 `null` 



### WebSocket协议跨域

WebSocket允许跨域的全双工通信



## JSONP和CORS的优缺点比较

**JSONP**

* 优点：兼容性好 ---- 因为script 本身就隶属于 HTML 的标签
* 缺点：
  * 仅支持 **get 请求** --- 使用 URL 引入资源
  * script 标签会将资源作为 JS 代码执行，所以可能会被**注入恶意代码** 
  * **错误处理机制**不够完善

**CORS**

* 优点：

  * 使用**简单**方便、更为**安全**
  * 支持**多种HTTP请求**方式
  * 可以通过**onerror事件监听错误**，并且浏览器控制台会看到报错信息，利于排查。

* 缺点：存在兼容问题——仅支持 IE10 以上

  

## JSONP和CORS的应用场景区别

如果需要考虑**兼容性**：JSONP

如果需要发出**多种类型**的HTTP请求：CORS



## script、img、link标签为何不受同源限制

同源策略中允许跨域嵌入、跨域写，而限制跨域读操作，script、img、link标签都是跨域嵌入



## 跨域请求中，需要设置哪个属性为true,才能携带cookie信息？

```
withCredentials
```

如果在发送XMLHttpRequest**跨域请求**之前：

未设置withCredentials 为true（默认为false），那么就**不能携带cookie信息**。

设置withCredentials 为true，则可**携带cookie**，同时携带的 cookies也会受**同源策略**限制，不能被document.cookie 或 从头部相应请求的脚本等访问。

Access-Control-Allow-Credential















# Web安全相关

## XSS

### XSS简介

**XSS**（**跨站脚本攻击**）

XSS 是指**攻击者在Web页面（HTML 文件｜ DOM ）里注入恶意代码**，当用户浏览网页时，嵌入Web里面的恶意代码会**被执行**，从而对用户实施攻击。

> 浏览器的**同源策略**里面**允许嵌入不同源的第三方资源**，也间接造成了XSS相关安全问题，因为**浏览器无法区分被插入的文件是恶意的还是正常的**~



### XSS危害

* **窃取 Cookie 信息**，将用户的Cookie信息**通过 XMLHttpRequest 或者 Fetch（+ CORS）**发送给黑客的服务器，在其他电脑上模拟用户登录
  * 恶意注入的 JavaScript 脚本拥有所有的脚本权限：**通过“document.cookie”获取 Cookie**
* **监听用户行为**：使用“addEventListener”接口来监听键盘事件（输入密码等）
* 通过**修改 DOM** 伪造假的登录窗口，用于盗取用户输入用户名和密码等信息
* **在页面内生成浮窗广告**，这些广告会**严重地影响用户体验**



### XSS分类

XSS攻击根据效果的不同可以分为三类：**存储型，反射型 和基于 DOM 型 **。

* **存储型（持久型）**
  * **存储型 XSS** 会**把恶意代码 "存储" 到存在漏洞的服务器端**【稳定性强】
  * 当（其他）浏览器**访问对应页面**时，恶意代码就会包含在服务器**响应数据**中**返回并执行**，实施攻击
  * **常见场景**：社区或论坛的留言板
* **反射型（非持久型）**
  * **恶意脚本属于用户发送给网站请求中的一部分**，随后网站又把**恶意 JavaScript 脚本**返回给用户
    * 搜索框中的内容会**作为参数拼接到URL中**发送给服务器，一旦在参数中加入一些**浏览器中的可执行脚本**，服务器返回对应的页面/数据，恶意脚本会执行，也就形成了**反射型XSS**
  * 黑客通常会分析被攻击的网站，找到这样的漏洞，**构造恶意链接**，**比如在参数中加入 < script > 标签引用恶意脚本**，通过 QQ 群或者邮件等渠道**诱导用户点击**恶意链接
* **基于 DOM** 
  * 指**通过恶意脚本修改当前 Web 页面中的数据**（伪造登录窗口）

---

> 反射型XSS、存储型XSS 需要**在服务端拼接用户输入作为HTML输出到页面** => **服务端的安全漏洞**
>
> 基于 DOM型XSS是纯粹发生在**客户端**的攻击，利用**浏览器解析机制**导致的漏洞 => **前端的安全漏洞**



### 如何防御XSS攻击

> 思路：阻止**恶意脚本的注入** | 阻止**恶意消息的发送**（窃取cookie）

* **服务器对用户输入进行过滤或转码（关键字符）** 【**客户端的输入检查容易被绕过**】
  * **富文本**：引入白名单，允许 < a>、< div>、< img> 等比较安全的标签，而限制用户输入比较危险的 < iframe>、< script>、< form> 等标签
* **服务器的输出检查**
* **使用 Cookie 的 HttpOnly属性**（Javascript无法访问有HttpOnly属性的cookie）
  * 服务器通过 HTTP 响应头设置HttpOnly，**防止 XSS 攻击后Cookie被挟持**
* **充分利用CSP（内容安全策略）**，降低 XSS 攻击的概率
* **添加验证码**，防止脚本冒充用户提交危险操作（危险操作时验证用户）
* 对于一些不受信任的输入，还可以**限制其输入长度**

----

> CSP的功能如下
>
> * 可限制加载其他域下的资源文件 => 即使黑客插入了一个 JavaScript 文件也无法被加载
> * 禁止向第三方域提交数据 => 用户数据也不会外泄
> * 禁止执行内联脚本和未授权的脚本
> * 提供了上报机制 => 可以帮助开发者尽快发现有哪些 XSS 攻击，以便尽快修复问题。



## CSRF

### CSRF简介

CSRF（Cross Site Request Forgery，即跨站请求伪造）：**劫持受信任用户来向服务器发送非预期请求**

* 隐性前提（本质）：攻击者可以猜到重要操作的所有参数，进而可以**伪造用户请求**

### CSRF 攻击思想

1. 用户**登录了网站A**
2. 验证通过，在客户端存放了网站A的**Cookie**
3. 用户没有退出A网站（有些Cookie是持久型的），并且**访问了危险网站B**
4. **危险网站B**发出一个请求，要求**访问网站A**，浏览器会**携带**上面产生的cookie去访问A
5. A并不知道请求是来自于用户还是来自于危险网站B，但是由于请求中携带Cookie，就会**以用户权限来处理危险网站的请求**，这也就成功发动了CSRF攻击

> * 浏览器携带cookie
>   * 这里**与跨域无关**，向同一个服务器发请求时会**携带上对应Cookie，**而不管是从哪个网站发出请求。
>   * 实际上并不能拿到 Cookie，也无法读取内容。【新增的Samesite属性！禁止携带**第三方Cookie**】
>
> * **后端可以设置`Access-Control-Allow-Origin`**，浏览器会**判断访问网站是否是被允许的域**；允许就能获得数据，如果不允许就拦截返回的数据，不让JS脚本获取。【仍然能在NetWork中看到返回】
> * 而对于服务器返回的结果，由于**浏览器同源策略**的限制，攻击者也**无法进行解析**。因此，攻击者无法从返回的结果中得到任何东西，他所能做的就是**给服务器发送请求**，以执行请求中所描述的命令，**在服务器端直接改变数据的值**，而非窃取服务器中的数据。
>   * 比如用户登录后发送特定的请求可以去删除服务器端的数据：删帖？

### CSRF 攻击的防范

* **验证码（最简洁而有效，只能防御）**：CSRF 的攻击过程往往是在**用户不知情**的情况下构造网络请求，而验证码则**强制用户与应用发生交互**，才能完成最终请求。
  * 最**简洁有效**，但是**破坏了用户体验**。
* **Referer Check**：referer 是 HTTP 协议中的一个请求头，用于告知服务器**请求的来源**。因此，可以在服务端**检查**请求的 referer，如果不在合法的范围内，则可以认定请求为攻击请求。
  * 缺点：服务器并不能任何时候都获取 referer，因此无法成为防御 CSRF 攻击的主要手段
* **添加 token 验证**：CSRF 的本质是攻击者可以猜到重要操作的所有参数，进而可以伪造用户请求。那么只要在请求中放入**攻击者所不能伪造（猜测）的信息**，并且该信息**不存在于 Cookie 之中**，就可以防止CSRF攻击。可以在 HTTP 请求中以参数的形式加入一个**随机产生的 token**，并在服务器端建立一个**拦截器来验证**这个 token，如果请求中**没有 token 或者 token 内容不正确（在session中也有一份），则认为可能是 CSRF 攻击而拒绝该请求。**

